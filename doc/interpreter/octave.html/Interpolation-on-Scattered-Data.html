<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Interpolation on Scattered Data (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Interpolation on Scattered Data (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Interpolation on Scattered Data (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Geometry.html" rel="up" title="Geometry">
<link href="Vector-Rotation-Matrices.html" rel="next" title="Vector Rotation Matrices">
<link href="Convex-Hull.html" rel="prev" title="Convex Hull">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.center {text-align:center}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Interpolation-on-Scattered-Data">
<div class="nav-panel">
<p>
Next: <a href="Vector-Rotation-Matrices.html" accesskey="n" rel="next">Vector Rotation Matrices</a>, Previous: <a href="Convex-Hull.html" accesskey="p" rel="prev">Convex Hull</a>, Up: <a href="Geometry.html" accesskey="u" rel="up">Geometry</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Interpolation-on-Scattered-Data-1"><span>30.4 Interpolation on Scattered Data<a class="copiable-link" href="#Interpolation-on-Scattered-Data-1"> &para;</a></span></h3>

<p>An important use of the Delaunay tessellation is that it can be used to
interpolate from scattered data to an arbitrary set of points.  To do
this the N-simplex of the known set of points is calculated with
<code class="code">delaunay</code> or <code class="code">delaunayn</code>.  Then the simplices in to which the
desired points are found are identified.  Finally the vertices of the simplices
are used to interpolate to the desired points.  The functions that perform this
interpolation are <code class="code">griddata</code>, <code class="code">griddata3</code> and <code class="code">griddatan</code>.
</p>
<a class="anchor" id="XREFgriddata"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-griddata"><span class="category-def">: </span><span><code class="def-type"><var class="var">zi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">xi</var>, <var class="var">yi</var>)</code><a class="copiable-link" href="#index-griddata"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">zi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddata-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>] =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-griddata-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>)</code><a class="copiable-link" href="#index-griddata-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddata-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata-5"><span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-griddata-5"> &para;</a></span></dt>
<dd>
<p>Interpolate irregular 2-D and 3-D source data at specified points.
</p>
<p>For 2-D interpolation, the inputs <var class="var">x</var> and <var class="var">y</var> define the points
where the function <code class="code"><var class="var">z</var> = f (<var class="var">x</var>, <var class="var">y</var>)</code> is evaluated.
The inputs <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are either vectors of the same length,
or the unequal vectors <var class="var">x</var>, <var class="var">y</var> are expanded to a 2-D grid with
<code class="code">meshgrid</code> and <var class="var">z</var> is a 2-D matrix matching the resulting size of
the X-Y grid.
</p>
<p>The interpolation points are (<var class="var">xi</var>, <var class="var">yi</var>).  If, and only if,
<var class="var">xi</var> is a row vector and <var class="var">yi</var> is a column vector, then
<code class="code">meshgrid</code> will be used to create a mesh of interpolation points.
</p>
<p>For 3-D interpolation, the inputs <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> define the
points where the function <code class="code"><var class="var">v</var> = f (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code>
is evaluated.  The inputs <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are either vectors of
the same length, or if they are of unequal length, then they are expanded to
a 3-D grid with <code class="code">meshgrid</code>.  The size of the input <var class="var">v</var> must match
the size of the original data, either as a vector or a matrix.
</p>
<p>The optional input interpolation <var class="var">method</var> can be <code class="code">&quot;nearest&quot;</code>,
<code class="code">&quot;linear&quot;</code>, or for 2-D data <code class="code">&quot;v4&quot;</code>.  When the method is
<code class="code">&quot;nearest&quot;</code>, the output <var class="var">vi</var> will be the closest point in the
original data (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>) to the query point (<var class="var">xi</var>,
<var class="var">yi</var>, <var class="var">zi</var>).  When the method is <code class="code">&quot;linear&quot;</code>, the output
<var class="var">vi</var> will be a linear interpolation between the two closest points in
the original source data in each dimension.  For 2-D cases only, the
<code class="code">&quot;v4&quot;</code> method is also available which implements a biharmonic spline
interpolation.  If <var class="var">method</var> is omitted or empty, it defaults to
<code class="code">&quot;linear&quot;</code>.
</p>
<p>For 3-D interpolation, the optional argument <var class="var">options</var> is passed
directly to Qhull when computing the Delaunay triangulation used for
interpolation.  For more information on the defaults and how to pass
different values, see <a class="pxref" href="Delaunay-Triangulation.html#XREFdelaunayn"><code class="code">delaunayn</code></a>.
</p>
<p>Programming Notes: If the input is complex the real and imaginary parts
are interpolated separately.  Interpolation is normally based on a
Delaunay triangulation.  Any query values outside the convex hull of the
input points will return <code class="code">NaN</code>.  However, the <code class="code">&quot;v4&quot;</code> method does
not use the triangulation and will return values outside the original data
(extrapolation).
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgriddata3">griddata3</a>, <a class="ref" href="#XREFgriddatan">griddatan</a>, <a class="ref" href="Delaunay-Triangulation.html#XREFdelaunay">delaunay</a>.
</p></dd></dl>


<a class="anchor" id="XREFgriddata3"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-griddata3"><span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>)</code><a class="copiable-link" href="#index-griddata3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata3-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddata3-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddata3-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">vi</var> =</code> <strong class="def-name">griddata3</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">v</var>, <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>, <var class="var">method</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-griddata3-2"> &para;</a></span></dt>
<dd>
<p>Interpolate irregular 3-D source data at specified points.
</p>
<p>The inputs <var class="var">x</var>, <var class="var">y</var>, and <var class="var">z</var> define the points where the
function <code class="code"><var class="var">v</var> = f (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)</code> is evaluated.  The
inputs <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var> are either vectors of the same length, or
if they are of unequal length, then they are expanded to a 3-D grid with
<code class="code">meshgrid</code>.  The size of the input <var class="var">v</var> must match the size of the
original data, either as a vector or a matrix.
</p>
<p>The interpolation points are specified by <var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>.
</p>
<p>The optional input interpolation <var class="var">method</var> can be <code class="code">&quot;nearest&quot;</code> or
<code class="code">&quot;linear&quot;</code>.  When the method is <code class="code">&quot;nearest&quot;</code>, the output <var class="var">vi</var>
will be the closest point in the original data (<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>)
to the query point (<var class="var">xi</var>, <var class="var">yi</var>, <var class="var">zi</var>).  When the method is
<code class="code">&quot;linear&quot;</code>, the output <var class="var">vi</var> will be a linear interpolation between
the two closest points in the original source data in each dimension.
If <var class="var">method</var> is omitted or empty, it defaults to <code class="code">&quot;linear&quot;</code>.
</p>
<p>The optional argument <var class="var">options</var> is passed directly to Qhull when
computing the Delaunay triangulation used for interpolation.  See
<code class="code">delaunayn</code> for information on the defaults and how to pass different
values.
</p>
<p>Programming Notes: If the input is complex the real and imaginary parts
are interpolated separately.  Interpolation is based on a Delaunay
triangulation and any query values outside the convex hull of the input
points will return <code class="code">NaN</code>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgriddata">griddata</a>, <a class="ref" href="#XREFgriddatan">griddatan</a>, <a class="ref" href="Delaunay-Triangulation.html#XREFdelaunayn">delaunayn</a>.
</p></dd></dl>


<a class="anchor" id="XREFgriddatan"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-griddatan"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">griddatan</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-griddatan"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddatan-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">griddatan</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>, <var class="var">method</var>)</code><a class="copiable-link" href="#index-griddatan-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-griddatan-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">griddatan</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>, <var class="var">method</var>, <var class="var">options</var>)</code><a class="copiable-link" href="#index-griddatan-2"> &para;</a></span></dt>
<dd>
<p>Interpolate irregular source data <var class="var">x</var>, <var class="var">y</var> at points specified by
<var class="var">xi</var>.
</p>
<p>The input <var class="var">x</var> is an MxN matrix representing M points in an N-dimensional
space.  The input <var class="var">y</var> is a single-valued column vector (Mx1)
representing a function evaluated at the points <var class="var">x</var>, i.e.,
<code class="code"><var class="var">y</var> = fcn (<var class="var">x</var>)</code>.  The input <var class="var">xi</var> is a list of points
for which the function output <var class="var">yi</var> should be approximated through
interpolation.  <var class="var">xi</var> must have the same number of columns (<var class="var">N</var>)
as <var class="var">x</var> so that the dimensionality matches.
</p>
<p>The optional input interpolation <var class="var">method</var> can be <code class="code">&quot;nearest&quot;</code> or
<code class="code">&quot;linear&quot;</code>.  When the method is <code class="code">&quot;nearest&quot;</code>, the output <var class="var">yi</var>
will be the closest point in the original data <var class="var">x</var> to the query point
<var class="var">xi</var>.  When the method is <code class="code">&quot;linear&quot;</code>, the output <var class="var">yi</var> will
be a linear interpolation between the two closest points in the original
source data.  If <var class="var">method</var> is omitted or empty, it defaults to
<code class="code">&quot;linear&quot;</code>.
</p>
<p>The optional argument <var class="var">options</var> is passed directly to Qhull when
computing the Delaunay triangulation used for interpolation.  See
<code class="code">delaunayn</code> for information on the defaults and how to pass different
values.
</p>
<p>Example
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">## Evaluate sombrero() function at irregular data points
x = 16*gallery (&quot;uniformdata&quot;, [200,1], 1) - 8;
y = 16*gallery (&quot;uniformdata&quot;, [200,1], 11) - 8;
z = sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
## Create a regular grid and interpolate data
[xi, yi] = ndgrid (linspace (-8, 8, 50));
zi = griddatan ([x, y], z, [xi(:), yi(:)]);
zi = reshape (zi, size (xi));
## Plot results
clf ();
plot3 (x, y, z, &quot;or&quot;);
hold on
surf (xi, yi, zi);
legend (&quot;Original Data&quot;, &quot;Interpolated Data&quot;);
</pre></div></div>

<p>Programming Notes: If the input is complex the real and imaginary parts
are interpolated separately.  Interpolation is based on a Delaunay
triangulation and any query values outside the convex hull of the input
points will return <code class="code">NaN</code>.  For 2-D and 3-D data additional
interpolation methods are available by using the <code class="code">griddata</code> function.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgriddata">griddata</a>, <a class="ref" href="#XREFgriddata3">griddata3</a>, <a class="ref" href="Delaunay-Triangulation.html#XREFdelaunayn">delaunayn</a>.
</p></dd></dl>


<p>An example of the use of the <code class="code">griddata</code> function is
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">rand (&quot;state&quot;, 1);
x = 2*rand (1000,1) - 1;
y = 2*rand (size (x)) - 1;
z = sin (2*(x.^2+y.^2));
[xx,yy] = meshgrid (linspace (-1,1,32));
zz = griddata (x, y, z, xx, yy);
mesh (xx, yy, zz);
</pre></div></div>

<p>that interpolates from a random scattering of points, to a uniform grid.
The output of the above can be seen in <a class="ref" href="#fig_003agriddata">Figure 30.6</a>.
</p>
<div class="float" id="fig_003agriddata">
<div class="center"><img class="image" src="griddata.png" alt="griddata">
</div><div class="caption"><p><strong class="strong">Figure 30.6: </strong>Interpolation from a scattered data to a regular grid</p></div></div>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Vector-Rotation-Matrices.html">Vector Rotation Matrices</a>, Previous: <a href="Convex-Hull.html">Convex Hull</a>, Up: <a href="Geometry.html">Geometry</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
