<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Indexed Assignment Optimization (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Indexed Assignment Optimization (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Indexed Assignment Optimization (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Indexing-Objects.html" rel="up" title="Indexing Objects">
<link href="Defining-Indexing-And-Indexed-Assignment.html" rel="prev" title="Defining Indexing And Indexed Assignment">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Indexed-Assignment-Optimization">
<div class="nav-panel">
<p>
Previous: <a href="Defining-Indexing-And-Indexed-Assignment.html" accesskey="p" rel="prev">Defining Indexing And Indexed Assignment</a>, Up: <a href="Indexing-Objects.html" accesskey="u" rel="up">Indexing Objects</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Indexed-Assignment-Optimization-1"><span>34.3.2 Indexed Assignment Optimization<a class="copiable-link" href="#Indexed-Assignment-Optimization-1"> &para;</a></span></h4>

<p>Octave&rsquo;s ubiquitous lazily-copied pass-by-value semantics implies a problem for
performance of user-defined <code class="code">subsasgn</code> methods.  Imagine the following
call to <code class="code">subsasgn</code>
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">ss = substruct (&quot;()&quot;, {1});
x = subsasgn (x, ss, 1);
</pre></div></div>

<p>where the corresponding method looking like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">function x = subsasgn (x, ss, val)
  ...
  x.myfield (ss.subs{1}) = val;
endfunction
</pre></div></div>

<p>The problem is that on entry to the <code class="code">subsasgn</code> method, <code class="code">x</code> is still
referenced from the caller&rsquo;s scope, which means that the method will first need
to unshare (copy) <code class="code">x</code> and <code class="code">x.myfield</code> before performing the
assignment.  Upon completing the call, unless an error occurs, the result is
immediately assigned to <code class="code">x</code> in the caller&rsquo;s scope, so that the previous
value of <code class="code">x.myfield</code> is forgotten.  Hence, the Octave language implies a
copy of N elements (N being the size of <code class="code">x.myfield</code>), where modifying just
a single element would actually suffice.  In other words, a constant-time
operation is degraded to linear-time one.  This may be a real problem for user
classes that intrinsically store large arrays.
</p>
<p>To partially solve the problem Octave uses a special optimization for
user-defined <code class="code">subsasgn</code> methods coded as m-files.  When the method gets
called as a result of the built-in assignment syntax (not a direct
<code class="code">subsasgn</code> call as shown above), i.e., <code class="code">x(1)&nbsp;=&nbsp;1</code><!-- /@w -->,  <b class="b">AND</b> if
the <code class="code">subsasgn</code> method is declared with identical input and output
arguments, as in the example above, then Octave will ignore the copy of
<code class="code">x</code> inside the caller&rsquo;s scope; therefore, any changes made to <code class="code">x</code>
during the method execution will directly affect the caller&rsquo;s copy as well.
This allows, for instance, defining a polynomial class where modifying a single
element takes constant time.
</p>
<p>It is important to understand the implications that this optimization brings.
Since no extra copy of <code class="code">x</code> will exist in the caller&rsquo;s scope, it is
<em class="emph">solely</em> the callee&rsquo;s responsibility to not leave <code class="code">x</code> in an invalid
state if an error occurs during the execution.  Also, if the method partially
changes <code class="code">x</code> and then errors out, the changes <em class="emph">will</em> affect <code class="code">x</code>
in the caller&rsquo;s scope.  Deleting or completely replacing <code class="code">x</code> inside
subsasgn will not do anything, however, only indexed assignments matter.
</p>
<p>Since this optimization may change the way code works (especially if badly
written), a function <code class="code">optimize_subsasgn_calls</code> is provided to
control it.  This feature is enabled by default.  Another way to avoid
the optimization is to declare subsasgn methods with different output
and input arguments like this:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">function y = subsasgn (x, ss, val)
  ...
endfunction
</pre></div></div>

</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Defining-Indexing-And-Indexed-Assignment.html">Defining Indexing And Indexed Assignment</a>, Up: <a href="Indexing-Objects.html">Indexing Objects</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
