<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Special Functions (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Special Functions (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Special Functions (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Arithmetic.html" rel="up" title="Arithmetic">
<link href="Rational-Approximations.html" rel="next" title="Rational Approximations">
<link href="Utility-Functions.html" rel="prev" title="Utility Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Special-Functions">
<div class="nav-panel">
<p>
Next: <a href="Rational-Approximations.html" accesskey="n" rel="next">Rational Approximations</a>, Previous: <a href="Utility-Functions.html" accesskey="p" rel="prev">Utility Functions</a>, Up: <a href="Arithmetic.html" accesskey="u" rel="up">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Special-Functions-1"><span>17.6 Special Functions<a class="copiable-link" href="#Special-Functions-1"> &para;</a></span></h3>

<a class="anchor" id="XREFairy"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-airy"><span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-airy"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-airy-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(<var class="var">k</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-airy-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-airy-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">a</var> =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(<var class="var">k</var>, <var class="var">z</var>, <var class="var">scale</var>)</code><a class="copiable-link" href="#index-airy-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-airy-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">a</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">airy</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-airy-3"> &para;</a></span></dt>
<dd>
<p>Compute Airy functions of the first and second kind, and their derivatives.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"> K   Function   Scale factor (if <var class="var">scale</var> is true)
---  --------   ---------------------------------------
 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))
</pre></div></div>

<p>The function call <code class="code">airy (<var class="var">z</var>)</code> is equivalent to
<code class="code">airy (0, <var class="var">z</var>)</code>.
</p>
<p>The optional third input <var class="var">scale</var> determines whether to
apply scaling as described above.  It is false by default.
</p>
<p>The result <var class="var">a</var> is the same size as <var class="var">z</var>.
</p>
<p>The optional output <var class="var">ierr</var> contains the following status information and
is the same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Input error, return <code class="code">NaN</code>.

</li><li> Overflow, return <code class="code">Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half
 of machine accuracy.

</li><li> Loss of significance by argument reduction, output may be inaccurate.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code class="code">NaN</code>.
</li></ol>
</dd></dl>


<a class="anchor" id="XREFbesselj"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-besselj"><span class="category-def">: </span><span><code class="def-type"><var class="var">J</var> =</code> <strong class="def-name">besselj</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselj"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselj-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">J</var> =</code> <strong class="def-name">besselj</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besselj-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselj-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">J</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besselj</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-besselj-2"> &para;</a></span></dt>
<dd><p>Compute Bessel functions of the first kind.
</p>
<p>The order of the Bessel function <var class="var">alpha</var> must be real.  The points for
evaluation <var class="var">x</var> may be complex.
</p>
<p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">J</var> is
multiplied by <code class="code">exp&nbsp;(-abs&nbsp;(imag&nbsp;(<var class="var">x</var>)))</code><!-- /@w -->.
</p>
<p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>.  If <var class="var">x</var>
is a scalar, the result is the same size as <var class="var">alpha</var>.  If <var class="var">alpha</var> is a
row vector and <var class="var">x</var> is a column vector, the result is a matrix with
<code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns.
Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var class="var">ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Input error, return <code class="code">NaN</code>.

</li><li> Overflow, return <code class="code">Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Loss of significance by argument reduction, output may be inaccurate.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code class="code">NaN</code>.
</li></ol>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselk">besselk</a>, <a class="ref" href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a class="anchor" id="XREFbessely"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-bessely"><span class="category-def">: </span><span><code class="def-type"><var class="var">Y</var> =</code> <strong class="def-name">bessely</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-bessely"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-bessely-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">Y</var> =</code> <strong class="def-name">bessely</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-bessely-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-bessely-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Y</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">bessely</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-bessely-2"> &para;</a></span></dt>
<dd><p>Compute Bessel functions of the second kind.
</p>
<p>The order of the Bessel function <var class="var">alpha</var> must be real.  The points for
evaluation <var class="var">x</var> may be complex.
</p>
<p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">Y</var> is
multiplied by <code class="code">exp&nbsp;(-abs&nbsp;(imag&nbsp;(<var class="var">x</var>)))</code><!-- /@w -->.
</p>
<p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>.  If <var class="var">x</var>
is a scalar, the result is the same size as <var class="var">alpha</var>.  If <var class="var">alpha</var> is a
row vector and <var class="var">x</var> is a column vector, the result is a matrix with
<code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns.
Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var class="var">ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Input error, return <code class="code">NaN</code>.

</li><li> Overflow, return <code class="code">Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code class="code">NaN</code>.
</li></ol>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselk">besselk</a>, <a class="ref" href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a class="anchor" id="XREFbesseli"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-besseli"><span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">besseli</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besseli"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besseli-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">besseli</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besseli-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besseli-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">I</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besseli</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-besseli-2"> &para;</a></span></dt>
<dd><p>Compute modified Bessel functions of the first kind.
</p>
<p>The order of the Bessel function <var class="var">alpha</var> must be real.  The points for
evaluation <var class="var">x</var> may be complex.
</p>
<p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">I</var> is
multiplied by <code class="code">exp&nbsp;(-abs&nbsp;(real&nbsp;(<var class="var">x</var>)))</code><!-- /@w -->.
</p>
<p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>.  If <var class="var">x</var>
is a scalar, the result is the same size as <var class="var">alpha</var>.  If <var class="var">alpha</var> is a
row vector and <var class="var">x</var> is a column vector, the result is a matrix with
<code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns.
Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var class="var">ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Input error, return <code class="code">NaN</code>.

</li><li> Overflow, return <code class="code">Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code class="code">NaN</code>.
</li></ol>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesselk">besselk</a>, <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a class="anchor" id="XREFbesselk"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-besselk"><span class="category-def">: </span><span><code class="def-type"><var class="var">K</var> =</code> <strong class="def-name">besselk</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselk"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselk-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">K</var> =</code> <strong class="def-name">besselk</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besselk-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselk-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">K</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besselk</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-besselk-2"> &para;</a></span></dt>
<dd>
<p>Compute modified Bessel functions of the second kind.
</p>
<p>The order of the Bessel function <var class="var">alpha</var> must be real.  The points for
evaluation <var class="var">x</var> may be complex.
</p>
<p>If the optional argument <var class="var">opt</var> is 1 or true, the result <var class="var">K</var> is
multiplied by <code class="code">exp&nbsp;(<var class="var">x</var>)</code><!-- /@w -->.
</p>
<p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>.  If <var class="var">x</var>
is a scalar, the result is the same size as <var class="var">alpha</var>.  If <var class="var">alpha</var> is a
row vector and <var class="var">x</var> is a column vector, the result is a matrix with
<code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns.
Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var class="var">ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Input error, return <code class="code">NaN</code>.

</li><li> Overflow, return <code class="code">Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code class="code">NaN</code>.
</li></ol>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesselh">besselh</a>.
</p></dd></dl>


<a class="anchor" id="XREFbesselh"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-besselh"><span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselh"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselh-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">k</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-besselh-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselh-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(<var class="var">alpha</var>, <var class="var">k</var>, <var class="var">x</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-besselh-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-besselh-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">H</var>, <var class="var">ierr</var>] =</code> <strong class="def-name">besselh</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-besselh-3"> &para;</a></span></dt>
<dd><p>Compute Bessel functions of the third kind (Hankel functions).
</p>
<p>The order of the Bessel function <var class="var">alpha</var> must be real.  The kind of Hankel
function is specified by <var class="var">k</var> and may be either first (<var class="var">k</var> = 1) or
second (<var class="var">k</var> = 2).  The default is Hankel functions of the first kind.  The
points for evaluation <var class="var">x</var> may be complex.
</p>
<p>If the optional argument <var class="var">opt</var> is 1 or true, the result is multiplied
by <code class="code">exp (-I*<var class="var">x</var>)</code> for <var class="var">k</var> = 1 or <code class="code">exp (I*<var class="var">x</var>)</code> for
<var class="var">k</var> = 2.
</p>
<p>If <var class="var">alpha</var> is a scalar, the result is the same size as <var class="var">x</var>.  If <var class="var">x</var>
is a scalar, the result is the same size as <var class="var">alpha</var>.  If <var class="var">alpha</var> is a
row vector and <var class="var">x</var> is a column vector, the result is a matrix with
<code class="code">length (<var class="var">x</var>)</code> rows and <code class="code">length (<var class="var">alpha</var>)</code> columns.
Otherwise, <var class="var">alpha</var> and <var class="var">x</var> must conform and the result will be the same
size.
</p>
<p>If requested, <var class="var">ierr</var> contains the following status information and is the
same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Input error, return <code class="code">NaN</code>.

</li><li> Overflow, return <code class="code">Inf</code>.

</li><li> Loss of significance by argument reduction results in less than half of machine
accuracy.

</li><li> Complete loss of significance by argument reduction, return <code class="code">NaN</code>.

</li><li> Error&mdash;no computation, algorithm termination condition not met, return
<code class="code">NaN</code>.
</li></ol>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbesselj">besselj</a>, <a class="ref" href="#XREFbessely">bessely</a>, <a class="ref" href="#XREFbesseli">besseli</a>, <a class="ref" href="#XREFbesselk">besselk</a>.
</p></dd></dl>


<a class="anchor" id="XREFbeta"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-beta"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">beta</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-beta"> &para;</a></span></dt>
<dd><p>Compute the Beta function for real inputs <var class="var">a</var> and <var class="var">b</var>.
</p>
<p>The Beta function definition is
</p>
<div class="example">
<pre class="example-preformatted">beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
</pre></div>


<p>The Beta function can grow quite large and it is often more useful to work
with the logarithm of the output rather than the function directly.
See <a class="xref" href="#XREFbetaln"><code class="code">betaln</code></a>, for computing the logarithm of the Beta
function in an efficient manner.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbetaln">betaln</a>, <a class="ref" href="#XREFbetainc">betainc</a>, <a class="ref" href="#XREFbetaincinv">betaincinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFbetainc"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-betainc"><span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">betainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-betainc"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-betainc-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">I</var> =</code> <strong class="def-name">betainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>, <var class="var">tail</var>)</code><a class="copiable-link" href="#index-betainc-1"> &para;</a></span></dt>
<dd><p>Compute the incomplete beta function.
</p>
<p>This is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                          x
                         /
                 1       |
I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
             beta (a,b)  |
                         /
                        0
</pre></div></div>


<p>with real <var class="var">x</var> in the range [0,1].  The inputs <var class="var">a</var> and <var class="var">b</var> must
be real and strictly positive (&gt; 0).  If one of the inputs is not a scalar
then the other inputs must be scalar or of compatible dimensions.
</p>
<p>By default, <var class="var">tail</var> is <code class="code">&quot;lower&quot;</code> and the incomplete beta function
integrated from 0 to <var class="var">x</var> is computed.  If <var class="var">tail</var> is <code class="code">&quot;upper&quot;</code>
then the complementary function integrated from <var class="var">x</var> to 1 is calculated.
The two choices are related by
</p>
<p>betainc (<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>, <code class="code">&quot;upper&quot;</code>) =
1 - betainc (<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>, <code class="code">&quot;lower&quot;</code>).
</p>
<p><code class="code">betainc</code> uses a more sophisticated algorithm than subtraction to
get numerically accurate results when the <code class="code">&quot;lower&quot;</code> value is small.
</p>
<p>Reference: A. Cuyt, V. Brevik Petersen, B. Verdonk, H. Waadeland,
W.B. Jones, <cite class="cite">Handbook of Continued Fractions for Special Functions</cite>,
ch. 18.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbeta">beta</a>, <a class="ref" href="#XREFbetaincinv">betaincinv</a>, <a class="ref" href="#XREFbetaln">betaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFbetaincinv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-betaincinv"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">betaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-betaincinv"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-betaincinv-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">betaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>, &quot;lower&quot;)</code><a class="copiable-link" href="#index-betaincinv-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-betaincinv-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">betaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>, &quot;upper&quot;)</code><a class="copiable-link" href="#index-betaincinv-2"> &para;</a></span></dt>
<dd><p>Compute the inverse of the normalized incomplete beta function.
</p>
<p>The normalized incomplete beta function is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                          x
                         /
                 1       |
I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
             beta (a,b)  |
                         /
                        0
</pre></div></div>


<p>If two inputs are scalar, then <code class="code">betaincinv (<var class="var">y</var>, <var class="var">a</var>, <var class="var">b</var>)</code>
is returned for each of the other inputs.
</p>
<p>If two or more inputs are not scalar, the sizes of them must agree, and
<code class="code">betaincinv</code> is applied element-by-element.
</p>
<p>The variable <var class="var">y</var> must be in the interval [0,1], while <var class="var">a</var> and
<var class="var">b</var> must be real and strictly positive.
</p>
<p>By default, <var class="var">tail</var> is <code class="code">&quot;lower&quot;</code> and the inverse of the incomplete
beta function integrated from 0 to <var class="var">x</var> is computed.  If <var class="var">tail</var> is
<code class="code">&quot;upper&quot;</code> then the complementary function integrated from <var class="var">x</var> to 1
is inverted.
</p>
<p>The function is computed by standard Newton&rsquo;s method, by solving
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">y</var> - betainc (<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>) = 0
</pre></div>



<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbetainc">betainc</a>, <a class="ref" href="#XREFbeta">beta</a>, <a class="ref" href="#XREFbetaln">betaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFbetaln"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-betaln"><span class="category-def">: </span><span><code class="def-type"><var class="var">lnb</var> =</code> <strong class="def-name">betaln</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-betaln"> &para;</a></span></dt>
<dd><p>Compute the natural logarithm of the Beta function for real inputs <var class="var">a</var>
and <var class="var">b</var>.
</p>
<p><code class="code">betaln</code> is defined as
</p>
<div class="example">
<pre class="example-preformatted">betaln (a, b) = log (beta (a, b))
</pre></div>

<p>and is calculated in a way to reduce the occurrence of underflow.
</p>
<p>The Beta function can grow quite large and it is often more useful to work
with the logarithm of the output rather than the function directly.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFbeta">beta</a>, <a class="ref" href="#XREFbetainc">betainc</a>, <a class="ref" href="#XREFbetaincinv">betaincinv</a>, <a class="ref" href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFbincoeff"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-bincoeff"><span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">bincoeff</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-bincoeff"> &para;</a></span></dt>
<dd><p>Return the binomial coefficient of <var class="var">n</var> and <var class="var">k</var>.
</p>
<p>The binomial coefficient is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"> /   \
 | n |    n (n-1) (n-2) ... (n-k+1)
 |   |  = -------------------------
 | k |               k!
 \   /
</pre></div></div>

<p>For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">bincoeff (5, 2)
   &rArr; 10
</pre></div></div>

<p>In most cases, the <code class="code">nchoosek</code> function is faster for small
scalar integer arguments.  It also warns about loss of precision for
big arguments.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="Basic-Statistical-Functions.html#XREFnchoosek">nchoosek</a>.
</p></dd></dl>


<a class="anchor" id="XREFcommutation_005fmatrix"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-commutation_005fmatrix"><span class="category-def">: </span><span><code class="def-type"><var class="var">k</var> =</code> <strong class="def-name">commutation_matrix</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-commutation_005fmatrix"> &para;</a></span></dt>
<dd><p>Return the commutation matrix
K(m,n)
which is the unique
<var class="var">m</var>*<var class="var">n</var> by <var class="var">m</var>*<var class="var">n</var>
matrix such that
<em class="math">K(m,n) * vec(A) = vec(A')</em>
for all
<em class="math">m</em> by <em class="math">n</em>
matrices
<em class="math">A</em>.
</p>
<p>If only one argument <var class="var">m</var> is given,
<em class="math">K(m,m)</em>
is returned.
</p>
<p>See Magnus and Neudecker (1988), <cite class="cite">Matrix Differential
Calculus with Applications in Statistics and Econometrics</cite>.
</p></dd></dl>


<a class="anchor" id="XREFcosint"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cosint"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">cosint</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cosint"> &para;</a></span></dt>
<dd><p>Compute the cosine integral function:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">            +oo
           /
Ci (x) = - | (cos (t)) / t dt
           /
          x
</pre></div></div>

<p>An equivalent definition is
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                             x
                            /
                            |  cos (t) - 1
Ci (x) = gamma + log (x) +  | -------------  dt
                            |        t
                            /
                           0
</pre></div></div>

<p>Reference:
</p>
<p>M. Abramowitz and I.A. Stegun,
<cite class="cite">Handbook of Mathematical Functions</cite>, 1964.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsinint">sinint</a>, <a class="ref" href="#XREFexpint">expint</a>, <a class="ref" href="Trigonometry.html#XREFcos">cos</a>.
</p>
</dd></dl>


<a class="anchor" id="XREFduplication_005fmatrix"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-duplication_005fmatrix"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">duplication_matrix</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-duplication_005fmatrix"> &para;</a></span></dt>
<dd><p>Return the duplication matrix
<em class="math">Dn</em>
which is the unique
<em class="math">N^2</em>-by-<em class="math">N*(N+1)/2</em>
matrix such that
<code class="code">Dn * vech (A) = vec (A)</code>
for all symmetric
<em class="math">N</em>-by-<em class="math">N</em>
matrices
<em class="math">A</em>.
</p>
<p>See Magnus and Neudecker (1988), <cite class="cite">Matrix Differential
Calculus with Applications in Statistics and Econometrics</cite>.
</p></dd></dl>


<a class="anchor" id="XREFdawson"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-dawson"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">dawson</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-dawson"> &para;</a></span></dt>
<dd><p>Compute the Dawson (scaled imaginary error) function.
</p>
<p>The Dawson function is defined as
</p>
<div class="example">
<pre class="example-preformatted">(sqrt (pi) / 2) * exp (-z^2) * erfi (z)
</pre></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFellipj"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ellipj"><span class="category-def">: </span><span><code class="def-type">[<var class="var">sn</var>, <var class="var">cn</var>, <var class="var">dn</var>, <var class="var">err</var>] =</code> <strong class="def-name">ellipj</strong> <code class="def-code-arguments">(<var class="var">u</var>, <var class="var">m</var>)</code><a class="copiable-link" href="#index-ellipj"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ellipj-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">sn</var>, <var class="var">cn</var>, <var class="var">dn</var>, <var class="var">err</var>] =</code> <strong class="def-name">ellipj</strong> <code class="def-code-arguments">(<var class="var">u</var>, <var class="var">m</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-ellipj-1"> &para;</a></span></dt>
<dd><p>Compute the Jacobi elliptic functions <var class="var">sn</var>, <var class="var">cn</var>, and <var class="var">dn</var>
of complex argument <var class="var">u</var> and real parameter <var class="var">m</var>.
</p>
<p>If <var class="var">m</var> is a scalar, the results are the same size as <var class="var">u</var>.
If <var class="var">u</var> is a scalar, the results are the same size as <var class="var">m</var>.
If <var class="var">u</var> is a column vector and <var class="var">m</var> is a row vector, the
results are matrices with <code class="code">length (<var class="var">u</var>)</code> rows and
<code class="code">length (<var class="var">m</var>)</code> columns.  Otherwise, <var class="var">u</var> and
<var class="var">m</var> must conform in size and the results will be the same size as the
inputs.
</p>
<p>The value of <var class="var">u</var> may be complex.
The value of <var class="var">m</var> must be 0 &le; <var class="var">m</var> &le; 1.
</p>
<p>The optional input <var class="var">tol</var> is currently ignored (<small class="sc">MATLAB</small> uses this to
allow faster, less accurate approximation).
</p>
<p>If requested, <var class="var">err</var> contains the following status information
and is the same size as the result.
</p>
<ol class="enumerate" start="0">
<li> Normal return.

</li><li> Error&mdash;no computation, algorithm termination condition not met,
return <code class="code">NaN</code>.
</li></ol>

<p>Reference: Milton Abramowitz and Irene A Stegun,
<cite class="cite">Handbook of Mathematical Functions</cite>, Chapter 16 (Sections 16.4, 16.13,
and 16.15), Dover, 1965.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFellipke">ellipke</a>.
</p></dd></dl>


<a class="anchor" id="XREFellipke"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ellipke"><span class="category-def">: </span><span><code class="def-type"><var class="var">k</var> =</code> <strong class="def-name">ellipke</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-ellipke"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ellipke-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">k</var> =</code> <strong class="def-name">ellipke</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-ellipke-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ellipke-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">k</var>, <var class="var">e</var>] =</code> <strong class="def-name">ellipke</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-ellipke-2"> &para;</a></span></dt>
<dd><p>Compute complete elliptic integrals of the first K(<var class="var">m</var>) and second
E(<var class="var">m</var>) kind.
</p>
<p><var class="var">m</var> must be a scalar or real array with -Inf &le; <var class="var">m</var> &le; 1.
</p>
<p>The optional input <var class="var">tol</var> controls the stopping tolerance of the
algorithm and defaults to <code class="code">eps (class (<var class="var">m</var>))</code>.  The tolerance can
be increased to compute a faster, less accurate approximation.
</p>
<p>When called with one output only elliptic integrals of the first kind are
returned.
</p>
<p>Mathematical Note:
</p>
<p>Elliptic integrals of the first kind are defined as
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">         1
        /               dt
K (m) = | ------------------------------
        / sqrt ((1 - t^2)*(1 - m*t^2))
       0
</pre></div></div>


<p>Elliptic integrals of the second kind are defined as
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">         1
        /  sqrt (1 - m*t^2)
E (m) = |  ------------------ dt
        /  sqrt (1 - t^2)
       0
</pre></div></div>


<p>Reference: Milton Abramowitz and Irene A. Stegun,
<cite class="cite">Handbook of Mathematical Functions</cite>, Chapter 17, Dover, 1965.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFellipj">ellipj</a>.
</p></dd></dl>


<a class="anchor" id="XREFerf"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-erf"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erf</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erf"> &para;</a></span></dt>
<dd><p>Compute the error function.
</p>
<p>The error function is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                        z
              2        /
erf (z) = --------- *  | e^(-t^2) dt
          sqrt (pi)    /
                    t=0
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFerfc"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-erfc"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erfc</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erfc"> &para;</a></span></dt>
<dd><p>Compute the complementary error function.
</p>
<p>The complementary error function is defined as
<code class="code">1&nbsp;-&nbsp;erf&nbsp;(<var class="var">z</var>)</code><!-- /@w -->.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfcinv">erfcinv</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfinv">erfinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFerfcx"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-erfcx"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erfcx</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erfcx"> &para;</a></span></dt>
<dd><p>Compute the scaled complementary error function.
</p>
<p>The scaled complementary error function is defined as
</p>
<div class="example">
<pre class="example-preformatted">exp (z^2) * erfc (z)
</pre></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFerfi"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-erfi"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">erfi</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-erfi"> &para;</a></span></dt>
<dd><p>Compute the imaginary error function.
</p>
<p>The imaginary error function is defined as
</p>
<div class="example">
<pre class="example-preformatted">-i * erf (i*z)
</pre></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFerfinv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-erfinv"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">erfinv</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-erfinv"> &para;</a></span></dt>
<dd><p>Compute the inverse error function.
</p>
<p>The inverse error function is defined such that
</p>
<div class="example">
<pre class="example-preformatted">erf (<var class="var">y</var>) == <var class="var">x</var>
</pre></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfcinv">erfcinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFerfcinv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-erfcinv"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">erfcinv</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-erfcinv"> &para;</a></span></dt>
<dd><p>Compute the inverse complementary error function.
</p>
<p>The inverse complementary error function is defined such that
</p>
<div class="example">
<pre class="example-preformatted">erfc (<var class="var">y</var>) == <var class="var">x</var>
</pre></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFerfc">erfc</a>, <a class="ref" href="#XREFerf">erf</a>, <a class="ref" href="#XREFerfcx">erfcx</a>, <a class="ref" href="#XREFerfi">erfi</a>, <a class="ref" href="#XREFdawson">dawson</a>, <a class="ref" href="#XREFerfinv">erfinv</a>.
</p></dd></dl>


<a class="anchor" id="XREFexpint"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-expint"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">expint</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-expint"> &para;</a></span></dt>
<dd><p>Compute the exponential integral.
</p>
<p>The exponential integral is defined as:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">           +oo
          /
          | exp (-t)
E_1 (x) = | -------- dt
          |    t
          /
         x
</pre></div></div>


<p>Note: For compatibility, this function uses the <small class="sc">MATLAB</small> definition
of the exponential integral.  Most other sources refer to this particular
value as <em class="math">E_1 (x)</em>, and the exponential integral as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">            +oo
           /
           | exp (-t)
Ei (x) = - | -------- dt
           |    t
           /
         -x
</pre></div></div>

<p>The two definitions are related, for positive real values of <var class="var">x</var>, by
<code class="code">E_1&nbsp;(-x)&nbsp;=&nbsp;-Ei&nbsp;(x)&nbsp;-&nbsp;i*pi</code><!-- /@w -->.
</p>
<p>References:
</p>
<p>M. Abramowitz and I.A. Stegun,
<cite class="cite">Handbook of Mathematical Functions</cite>, 1964.
</p>
<p>N. Bleistein and R.A. Handelsman,
<cite class="cite">Asymptotic expansions of integrals</cite>, 1986.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcosint">cosint</a>, <a class="ref" href="#XREFsinint">sinint</a>, <a class="ref" href="Exponents-and-Logarithms.html#XREFexp">exp</a>.
</p></dd></dl>


<a class="anchor" id="XREFgamma"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-gamma"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">gamma</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-gamma"> &para;</a></span></dt>
<dd><p>Compute the Gamma function.
</p>
<p>The Gamma function is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">             infinity
            /
gamma (z) = | t^(z-1) exp (-t) dt.
            /
         t=0
</pre></div></div>


<p>Programming Note: The gamma function can grow quite large even for small
input values.  In many cases it may be preferable to use the natural
logarithm of the gamma function (<code class="code">gammaln</code>) in calculations to minimize
loss of precision.  The final result is then
<code class="code">exp (<var class="var">result_using_gammaln</var>).</code>
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgammainc">gammainc</a>, <a class="ref" href="#XREFgammaln">gammaln</a>, <a class="ref" href="Utility-Functions.html#XREFfactorial">factorial</a>.
</p></dd></dl>


<a class="anchor" id="XREFgammainc"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-gammainc"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">gammainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-gammainc"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gammainc-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">gammainc</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">tail</var>)</code><a class="copiable-link" href="#index-gammainc-1"> &para;</a></span></dt>
<dd><p>Compute the normalized incomplete gamma function.
</p>
<p>This is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                                x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0
</pre></div></div>

<p>with the limiting value of 1 as <var class="var">x</var> approaches infinity.
The standard notation is <em class="math">P(a,x)</em>, e.g., Abramowitz and
Stegun (6.5.1).
</p>
<p>If <var class="var">a</var> is scalar, then <code class="code">gammainc (<var class="var">x</var>, <var class="var">a</var>)</code> is returned
for each element of <var class="var">x</var> and vice versa.
</p>
<p>If neither <var class="var">x</var> nor <var class="var">a</var> is scalar then the sizes of <var class="var">x</var> and
<var class="var">a</var> must agree, and <code class="code">gammainc</code> is applied element-by-element.
The elements of <var class="var">a</var> must be non-negative.
</p>
<p>By default, <var class="var">tail</var> is <code class="code">&quot;lower&quot;</code> and the incomplete gamma function
integrated from 0 to <var class="var">x</var> is computed.  If <var class="var">tail</var> is <code class="code">&quot;upper&quot;</code>
then the complementary function integrated from <var class="var">x</var> to infinity is
calculated.
</p>
<p>If <var class="var">tail</var> is <code class="code">&quot;scaledlower&quot;</code>, then the lower incomplete gamma
function is multiplied by
<em class="math">gamma(a+1)*exp(x)/(x^a)</em>.
If <var class="var">tail</var> is <code class="code">&quot;scaledupper&quot;</code>, then the upper incomplete gamma
function is multiplied by the same quantity.
</p>
<p>References:
</p>
<p>M. Abramowitz and I.A. Stegun,
<cite class="cite">Handbook of mathematical functions</cite>,
Dover publications, Inc., 1972.
</p>
<p>W. Gautschi,
<cite class="cite">A computational procedure for incomplete gamma functions</cite>,
ACM Trans. Math Software, pp. 466&ndash;481, Vol 5, No. 4, 2012.
</p>
<p>W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery,
<cite class="cite">Numerical Recipes in Fortran 77</cite>, ch. 6.2, Vol 1, 1992.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammaincinv">gammaincinv</a>, <a class="ref" href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFgammaincinv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-gammaincinv"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">gammaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-gammaincinv"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gammaincinv-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">gammaincinv</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">a</var>, <var class="var">tail</var>)</code><a class="copiable-link" href="#index-gammaincinv-1"> &para;</a></span></dt>
<dd><p>Compute the inverse of the normalized incomplete gamma function.
</p>
<p>The normalized incomplete gamma function is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                                x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0
</pre></div></div>


<p>and <code class="code">gammaincinv (gammainc (<var class="var">x</var>, <var class="var">a</var>), <var class="var">a</var>) = <var class="var">x</var></code>
for each non-negative value of <var class="var">x</var>.  If <var class="var">a</var> is scalar then
<code class="code">gammaincinv (<var class="var">y</var>, <var class="var">a</var>)</code> is returned for each element of
<var class="var">y</var> and vice versa.
</p>
<p>If neither <var class="var">y</var> nor <var class="var">a</var> is scalar then the sizes of <var class="var">y</var> and
<var class="var">a</var> must agree, and <code class="code">gammaincinv</code> is applied element-by-element.
The variable <var class="var">y</var> must be in the interval <em class="math">[0,1]</em> while <var class="var">a</var> must
be real and positive.
</p>
<p>By default, <var class="var">tail</var> is <code class="code">&quot;lower&quot;</code> and the inverse of the incomplete
gamma function integrated from 0 to <var class="var">x</var> is computed.  If <var class="var">tail</var> is
<code class="code">&quot;upper&quot;</code>, then the complementary function integrated from <var class="var">x</var> to
infinity is inverted.
</p>
<p>The function is computed with Newton&rsquo;s method by solving
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">y</var> - gammainc (<var class="var">x</var>, <var class="var">a</var>) = 0
</pre></div>


<p>Reference: A. Gil, J. Segura, and N. M. Temme, <cite class="cite">Efficient and
accurate algorithms for the computation and inversion of the incomplete
gamma function ratios</cite>, SIAM J. Sci. Computing, pp.
A2965&ndash;A2981, Vol 34, 2012.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgammainc">gammainc</a>, <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFlegendre"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-legendre"><span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">legendre</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-legendre"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-legendre-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">legendre</strong> <code class="def-code-arguments">(<var class="var">n</var>, <var class="var">x</var>, <var class="var">normalization</var>)</code><a class="copiable-link" href="#index-legendre-1"> &para;</a></span></dt>
<dd><p>Compute the associated Legendre function of degree <var class="var">n</var> and order
<var class="var">m</var> = 0 &hellip; <var class="var">n</var>.
</p>
<p>The value <var class="var">n</var> must be a real non-negative integer.
</p>
<p><var class="var">x</var> is a vector with real-valued elements in the range [-1, 1].
</p>
<p>The optional argument <var class="var">normalization</var> may be one of <code class="code">&quot;unnorm&quot;</code>,
<code class="code">&quot;sch&quot;</code>, or <code class="code">&quot;norm&quot;</code>.  The default if no normalization is given
is <code class="code">&quot;unnorm&quot;</code>.
</p>
<p>When the optional argument <var class="var">normalization</var> is <code class="code">&quot;unnorm&quot;</code>, compute
the associated Legendre function of degree <var class="var">n</var> and order <var class="var">m</var> and
return all values for <var class="var">m</var> = 0 &hellip; <var class="var">n</var>.  The return value has one
dimension more than <var class="var">x</var>.
</p>
<p>The associated Legendre function of degree <var class="var">n</var> and order <var class="var">m</var>:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted"> m         m      2  m/2   d^m
P(x) = (-1) * (1-x  )    * ----  P(x)
 n                         dx^m   n
</pre></div></div>


<p>with Legendre polynomial of degree <var class="var">n</var>:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">          1    d^n   2    n
P(x) = ------ [----(x - 1) ]
 n     2^n n!  dx^n
</pre></div></div>


<p><code class="code">legendre (3, [-1.0, -0.9, -0.8])</code> returns the matrix:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"> x  |   -1.0   |   -0.9   |   -0.8
------------------------------------
m=0 | -1.00000 | -0.47250 | -0.08000
m=1 |  0.00000 | -1.99420 | -1.98000
m=2 |  0.00000 | -2.56500 | -4.32000
m=3 |  0.00000 | -1.24229 | -3.24000
</pre></div></div>

<p>When the optional argument <var class="var">normalization</var> is <code class="code">&quot;sch&quot;</code>, compute
the Schmidt semi-normalized associated Legendre function.  The Schmidt
semi-normalized associated Legendre function is related to the unnormalized
Legendre functions by the following:
</p>
<p>For Legendre functions of degree <var class="var">n</var> and order 0:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">  0      0
SP(x) = P(x)
  n      n
</pre></div></div>


<p>For Legendre functions of degree n and order m:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">  m      m         m    2(n-m)! 0.5
SP(x) = P(x) * (-1)  * [-------]
  n      n              (n+m)!
</pre></div></div>


<p>When the optional argument <var class="var">normalization</var> is <code class="code">&quot;norm&quot;</code>, compute
the fully normalized associated Legendre function.  The fully normalized
associated Legendre function is related to the unnormalized associated
Legendre functions by the following:
</p>
<p>For Legendre functions of degree <var class="var">n</var> and order <var class="var">m</var>
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">  m      m         m    (n+0.5)(n-m)! 0.5
NP(x) = P(x) * (-1)  * [-------------]
  n      n                  (n+m)!
</pre></div></div>

</dd></dl>


<a class="anchor" id="XREFgammaln"></a><a class="anchor" id="XREFlgamma"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-gammaln"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">gammaln</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-gammaln"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lgamma"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">lgamma</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-lgamma"> &para;</a></span></dt>
<dd><p>Return the natural logarithm of the gamma function of <var class="var">x</var>.
</p>
<p>Programming Note: <code class="code">lgamma</code> is an alias for <code class="code">gammaln</code> and either name
can be used in Octave.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammainc">gammainc</a>.
</p></dd></dl>


<a class="anchor" id="XREFpsi"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-psi"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">psi</strong> <code class="def-code-arguments">(<var class="var">z</var>)</code><a class="copiable-link" href="#index-psi"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-psi-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">psi</strong> <code class="def-code-arguments">(<var class="var">k</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-psi-1"> &para;</a></span></dt>
<dd><p>Compute the psi (polygamma) function.
</p>
<p>The polygamma functions are the <var class="var">k</var>th derivative of the logarithm
of the gamma function.  If unspecified, <var class="var">k</var> defaults to zero.  A value
of zero computes the digamma function, a value of 1, the trigamma function,
and so on.
</p>
<p>The digamma function is defined:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">psi (z) = d (log (gamma (z))) / dx
</pre></div></div>


<p>When computing the digamma function (when <var class="var">k</var> equals zero), <var class="var">z</var>
can have any value real or complex value.  However, for polygamma functions
(<var class="var">k</var> higher than 0), <var class="var">z</var> must be real and non-negative.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgamma">gamma</a>, <a class="ref" href="#XREFgammainc">gammainc</a>, <a class="ref" href="#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFsinint"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-sinint"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinint</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sinint"> &para;</a></span></dt>
<dd><p>Compute the sine integral function:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">           x
          /
Si (x) =  | sin (t) / t dt
          /
         0
</pre></div></div>


<p>Reference:
M. Abramowitz and I.A. Stegun,
<cite class="cite">Handbook of Mathematical Functions</cite>, 1964.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcosint">cosint</a>, <a class="ref" href="#XREFexpint">expint</a>, <a class="ref" href="Trigonometry.html#XREFsin">sin</a>.
</p></dd></dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Rational-Approximations.html">Rational Approximations</a>, Previous: <a href="Utility-Functions.html">Utility Functions</a>, Up: <a href="Arithmetic.html">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
