<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Utility Functions (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Utility Functions (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Utility Functions (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Arithmetic.html" rel="up" title="Arithmetic">
<link href="Special-Functions.html" rel="next" title="Special Functions">
<link href="Sums-and-Products.html" rel="prev" title="Sums and Products">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Utility-Functions">
<div class="nav-panel">
<p>
Next: <a href="Special-Functions.html" accesskey="n" rel="next">Special Functions</a>, Previous: <a href="Sums-and-Products.html" accesskey="p" rel="prev">Sums and Products</a>, Up: <a href="Arithmetic.html" accesskey="u" rel="up">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Utility-Functions-1"><span>17.5 Utility Functions<a class="copiable-link" href="#Utility-Functions-1"> &para;</a></span></h3>

<a class="anchor" id="XREFceil"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ceil"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">ceil</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-ceil"> &para;</a></span></dt>
<dd><p>Return the smallest integer not less than <var class="var">x</var>.
</p>
<p>This is equivalent to rounding towards positive infinity.
</p>
<p>If <var class="var">x</var> is complex, return
<code class="code">ceil (real (<var class="var">x</var>)) + ceil (imag (<var class="var">x</var>)) * I</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">ceil ([-2.7, 2.7])
    &rArr; -2    3
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfloor">floor</a>, <a class="ref" href="#XREFround">round</a>, <a class="ref" href="#XREFfix">fix</a>.
</p></dd></dl>


<a class="anchor" id="XREFfix"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fix"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fix</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-fix"> &para;</a></span></dt>
<dd><p>Truncate fractional portion of <var class="var">x</var> and return the integer portion.
</p>
<p>This is equivalent to rounding towards zero.  If <var class="var">x</var> is complex, return
<code class="code">fix (real (<var class="var">x</var>)) + fix (imag (<var class="var">x</var>)) * I</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">fix ([-2.7, 2.7])
   &rArr; -2    2
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFceil">ceil</a>, <a class="ref" href="#XREFfloor">floor</a>, <a class="ref" href="#XREFround">round</a>.
</p></dd></dl>


<a class="anchor" id="XREFfloor"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-floor"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">floor</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-floor"> &para;</a></span></dt>
<dd><p>Return the largest integer not greater than <var class="var">x</var>.
</p>
<p>This is equivalent to rounding towards negative infinity.  If <var class="var">x</var> is
complex, return <code class="code">floor (real (<var class="var">x</var>)) + floor (imag (<var class="var">x</var>)) * I</code>.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">floor ([-2.7, 2.7])
     &rArr; -3    2
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFceil">ceil</a>, <a class="ref" href="#XREFround">round</a>, <a class="ref" href="#XREFfix">fix</a>.
</p></dd></dl>


<a class="anchor" id="XREFround"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-round"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">round</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-round"> &para;</a></span></dt>
<dd><p>Return the integer nearest to <var class="var">x</var>.
</p>
<p>If <var class="var">x</var> is complex, return
<code class="code">round (real (<var class="var">x</var>)) + round (imag (<var class="var">x</var>)) * I</code>.  If there
are two nearest integers, return the one further away from zero.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">round ([-2.7, 2.7])
     &rArr; -3    3
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFceil">ceil</a>, <a class="ref" href="#XREFfloor">floor</a>, <a class="ref" href="#XREFfix">fix</a>, <a class="ref" href="#XREFroundb">roundb</a>.
</p></dd></dl>


<a class="anchor" id="XREFroundb"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-roundb"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">roundb</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-roundb"> &para;</a></span></dt>
<dd><p>Return the integer nearest to <var class="var">x</var>.  If there are two nearest
integers, return the even one (banker&rsquo;s rounding).
</p>
<p>If <var class="var">x</var> is complex,
return <code class="code">roundb (real (<var class="var">x</var>)) + roundb (imag (<var class="var">x</var>)) * I</code>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFround">round</a>.
</p></dd></dl>


<a class="anchor" id="XREFmax"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-max"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-max"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-max-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>, [], <var class="var">dim</var>)</code><a class="copiable-link" href="#index-max-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-max-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">m</var>, <var class="var">im</var>] =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-max-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-max-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">max</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-max-3"> &para;</a></span></dt>
<dd><p>Find maximum values in the array <var class="var">x</var>.
</p>
<p>For a vector argument, return the maximum value.  For a matrix argument,
return a row vector with the maximum value of each column.  For a
multi-dimensional array, <code class="code">max</code> operates along the first non-singleton
dimension.
</p>
<p>If the optional third argument <var class="var">dim</var> is present then operate along
this dimension.  In this case the second argument is ignored and should be
set to the empty matrix.
</p>
<p>For two inputs (<var class="var">x</var> and <var class="var">y</var>), return the pairwise maximum according to
the rules for <a class="ref" href="Broadcasting.html">Broadcasting</a>.
</p>
<p>Thus,
</p>
<div class="example">
<pre class="example-preformatted">max (max (<var class="var">x</var>))
</pre></div>

<p>returns the largest element of the 2-D matrix <var class="var">x</var>, and
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">max (2:5, pi)
    &rArr;  3.1416  3.1416  4.0000  5.0000
</pre></div></div>

<p>compares each element of the range <code class="code">2:5</code> with <code class="code">pi</code>, and returns a
row vector of the maximum values.
</p>
<p>For complex arguments, the magnitude of the elements are used for
comparison.  If the magnitudes are identical, then the results are ordered
by phase angle in the range (-pi, pi].  Hence,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">max ([-1 i 1 -i])
    &rArr; -1
</pre></div></div>

<p>because all entries have magnitude 1, but -1 has the largest phase angle
with value pi.
</p>
<p>If called with one input and two output arguments, <code class="code">max</code> also returns
the first index of the maximum value(s).  Thus,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[x, ix] = max ([1, 3, 5, 2, 5])
    &rArr;  x = 5
        ix = 3
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmin">min</a>, <a class="ref" href="#XREFcummax">cummax</a>, <a class="ref" href="#XREFcummin">cummin</a>.
</p></dd></dl>


<a class="anchor" id="XREFmin"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-min"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-min"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-min-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>, [], <var class="var">dim</var>)</code><a class="copiable-link" href="#index-min-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-min-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">m</var>, <var class="var">im</var>] =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-min-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-min-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">min</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-min-3"> &para;</a></span></dt>
<dd><p>Find minimum values in the array <var class="var">x</var>.
</p>
<p>For a vector argument, return the minimum value.  For a matrix argument,
return a row vector with the minimum value of each column.  For a
multi-dimensional array, <code class="code">min</code> operates along the first non-singleton
dimension.
</p>
<p>If the optional third argument <var class="var">dim</var> is present then operate along
this dimension.  In this case the second argument is ignored and should be
set to the empty matrix.
</p>
<p>For two inputs (<var class="var">x</var> and <var class="var">y</var>), return the pairwise minimum according to
the rules for <a class="ref" href="Broadcasting.html">Broadcasting</a>.
</p>
<p>Thus,
</p>
<div class="example">
<pre class="example-preformatted">min (min (<var class="var">x</var>))
</pre></div>

<p>returns the smallest element of the 2-D matrix <var class="var">x</var>, and
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">min (2:5, pi)
    &rArr;  2.0000  3.0000  3.1416  3.1416
</pre></div></div>

<p>compares each element of the range <code class="code">2:5</code> with <code class="code">pi</code>, and returns a
row vector of the minimum values.
</p>
<p>For complex arguments, the magnitude of the elements are used for
comparison.  If the magnitudes are identical, then the results are ordered
by phase angle in the range (-pi, pi].  Hence,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">min ([-1 i 1 -i])
    &rArr; -i
</pre></div></div>

<p>because all entries have magnitude 1, but -i has the smallest phase angle
with value -pi/2.
</p>
<p>If called with one input and two output arguments, <code class="code">min</code> also returns
the first index of the minimum value(s).  Thus,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[x, ix] = min ([1, 3, 0, 2, 0])
    &rArr;  x = 0
        ix = 3
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmax">max</a>, <a class="ref" href="#XREFcummin">cummin</a>, <a class="ref" href="#XREFcummax">cummax</a>.
</p></dd></dl>


<a class="anchor" id="XREFcummax"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cummax"><span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummax</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cummax"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-cummax-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummax</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cummax-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-cummax-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">M</var>, <var class="var">IM</var>] =</code> <strong class="def-name">cummax</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-cummax-2"> &para;</a></span></dt>
<dd><p>Return the cumulative maximum values along dimension <var class="var">dim</var>.
</p>
<p>If <var class="var">dim</var> is unspecified it defaults to column-wise operation.  For
example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">cummax ([1 3 2 6 4 5])
   &rArr;  1  3  3  6  6  6
</pre></div></div>

<p>If called with two output arguments the index of the maximum value is also
returned.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[w, iw] = cummax ([1 3 2 6 4 5])
&rArr;
M =  1  3  3  6  6  6
IM = 1  2  2  4  4  4
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcummin">cummin</a>, <a class="ref" href="#XREFmax">max</a>, <a class="ref" href="#XREFmin">min</a>.
</p></dd></dl>


<a class="anchor" id="XREFcummin"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cummin"><span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummin</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cummin"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-cummin-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">M</var> =</code> <strong class="def-name">cummin</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cummin-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-cummin-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">M</var>, <var class="var">IM</var>] =</code> <strong class="def-name">cummin</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-cummin-2"> &para;</a></span></dt>
<dd><p>Return the cumulative minimum values along dimension <var class="var">dim</var>.
</p>
<p>If <var class="var">dim</var> is unspecified it defaults to column-wise operation.  For
example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">cummin ([5 4 6 2 3 1])
   &rArr;  5  4  4  2  2  1
</pre></div></div>

<p>If called with two output arguments the index of the minimum value is also
returned.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[M, IM] = cummin ([5 4 6 2 3 1])
&rArr;
M =  5  4  4  2  2  1
IM = 1  2  2  4  4  6
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcummax">cummax</a>, <a class="ref" href="#XREFmin">min</a>, <a class="ref" href="#XREFmax">max</a>.
</p></dd></dl>


<a class="anchor" id="XREFhypot"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-hypot"><span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">hypot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-hypot"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-hypot-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">hypot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, &hellip;)</code><a class="copiable-link" href="#index-hypot-1"> &para;</a></span></dt>
<dd><p>Compute the element-by-element square root of the sum of the squares of
<var class="var">x</var> and <var class="var">y</var>.
</p>
<p>This is equivalent to
<code class="code">sqrt (<var class="var">x</var>.^2 + <var class="var">y</var>.^2)</code>, but is calculated in a manner that
avoids overflows for large values of <var class="var">x</var> or <var class="var">y</var>.
</p>
<p><code class="code">hypot</code> can also be called with more than 2 arguments; in this case,
the arguments are accumulated from left to right:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">hypot (hypot (<var class="var">x</var>, <var class="var">y</var>), <var class="var">z</var>)
hypot (hypot (hypot (<var class="var">x</var>, <var class="var">y</var>), <var class="var">z</var>), <var class="var">w</var>), etc.
</pre></div></div>
</dd></dl>


<a class="anchor" id="XREFgradient"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-gradient"><span class="category-def">: </span><span><code class="def-type"><var class="var">dx</var> =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-gradient"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">dx</var>, <var class="var">dy</var>, <var class="var">dz</var>, &hellip;] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-gradient-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-2"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-gradient-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-3"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, &hellip;)</code><a class="copiable-link" href="#index-gradient-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-4"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">x0</var>)</code><a class="copiable-link" href="#index-gradient-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-5"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">x0</var>, <var class="var">s</var>)</code><a class="copiable-link" href="#index-gradient-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gradient-6"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">gradient</strong> <code class="def-code-arguments">(<var class="var">f</var>, <var class="var">x0</var>, <var class="var">x</var>, <var class="var">y</var>, &hellip;)</code><a class="copiable-link" href="#index-gradient-6"> &para;</a></span></dt>
<dd>
<p>Calculate the gradient of sampled data or a function.
</p>
<p>If <var class="var">m</var> is a vector, calculate the one-dimensional gradient of <var class="var">m</var>.
If <var class="var">m</var> is a matrix the gradient is calculated for each dimension.
</p>
<p><code class="code">[<var class="var">dx</var>, <var class="var">dy</var>] = gradient (<var class="var">m</var>)</code> calculates the
one-dimensional gradient for <var class="var">x</var> and <var class="var">y</var> direction if <var class="var">m</var> is a
matrix.  Additional return arguments can be use for multi-dimensional
matrices.
</p>
<p>A constant spacing between two points can be provided by the <var class="var">s</var>
parameter.  If <var class="var">s</var> is a scalar, it is assumed to be the spacing for all
dimensions.  Otherwise, separate values of the spacing can be supplied by
the <var class="var">x</var>, &hellip; arguments.  Scalar values specify an equidistant
spacing.  Vector values for the <var class="var">x</var>, &hellip; arguments specify the
coordinate for that dimension.  The length must match their respective
dimension of <var class="var">m</var>.
</p>
<p>At boundary points a linear extrapolation is applied.  Interior points
are calculated with the first approximation of the numerical gradient
</p>
<div class="example">
<pre class="example-preformatted">y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).
</pre></div>

<p>If the first argument <var class="var">f</var> is a function handle, the gradient of the
function at the points in <var class="var">x0</var> is approximated using central difference.
For example, <code class="code">gradient (@cos, 0)</code> approximates the gradient of the
cosine function in the point <em class="math">x0 = 0</em>.  As with sampled data, the
spacing values between the points from which the gradient is estimated can
be set via the <var class="var">s</var> or <var class="var">dx</var>, <var class="var">dy</var>, &hellip; arguments.  By default
a spacing of 1 is used.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Finding-Elements-and-Checking-Conditions.html#XREFdiff">diff</a>, <a class="ref" href="#XREFdel2">del2</a>.
</p></dd></dl>


<a class="anchor" id="XREFdot"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-dot"><span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">dot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-dot"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-dot-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">dot</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-dot-1"> &para;</a></span></dt>
<dd><p>Compute the dot product of two vectors.
</p>
<p>If <var class="var">x</var> and <var class="var">y</var> are matrices, calculate the dot products along the
first non-singleton dimension.
</p>
<p>If the optional argument <var class="var">dim</var> is given, calculate the dot products
along this dimension.
</p>
<p>Implementation Note: This is equivalent to
<code class="code">sum (conj (<var class="var">X</var>) .* <var class="var">Y</var>, <var class="var">dim</var>)</code>, but avoids forming a
temporary array and is faster.  When <var class="var">X</var> and <var class="var">Y</var> are column vectors,
the result is equivalent to <code class="code"><var class="var">X</var>' * <var class="var">Y</var></code>.  Although, <code class="code">dot</code>
is defined for integer arrays, the output may differ from the expected result
due to the limited range of integer objects.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcross">cross</a>, <a class="ref" href="#XREFdivergence">divergence</a>, <a class="ref" href="Functions-of-a-Matrix.html#XREFtensorprod">tensorprod</a>.
</p></dd></dl>


<a class="anchor" id="XREFcross"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cross"><span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">cross</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-cross"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-cross-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">cross</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-cross-1"> &para;</a></span></dt>
<dd><p>Compute the vector cross product of two 3-dimensional vectors <var class="var">x</var> and
<var class="var">y</var>.
</p>
<p>If <var class="var">x</var> and <var class="var">y</var> are arrays, the cross product is applied along the
first dimension with three elements.
</p>
<p>The optional argument  <var class="var">dim</var> forces the cross product to be calculated
along the specified dimension.  An error will be produced if the specified
dimension is not three elements in size.
</p>
<p>Example Code:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">cross ([1, 1, 0], [0, 1, 1])
  &rArr;
       1  -1   1
</pre></div></div>

<div class="example">
<div class="group"><pre class="example-preformatted">cross (magic (3), eye (3), 2)
  &rArr;
       0   6  -1
      -7   0   3
       9  -4   0
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdot">dot</a>, <a class="ref" href="#XREFcurl">curl</a>, <a class="ref" href="#XREFdivergence">divergence</a>.
</p></dd></dl>


<a class="anchor" id="XREFdivergence"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-divergence"><span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-divergence"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-divergence-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-divergence-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-divergence-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-divergence-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-divergence-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">div</var> =</code> <strong class="def-name">divergence</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-divergence-3"> &para;</a></span></dt>
<dd><p>Calculate divergence of a vector field given by the arrays <var class="var">fx</var>,
<var class="var">fy</var>, and <var class="var">fz</var> or <var class="var">fx</var>, <var class="var">fy</var> respectively.
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">                  d               d               d
div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
                  dx              dy              dz
</pre></div></div>

<p>The coordinates of the vector field can be given by the arguments <var class="var">x</var>,
<var class="var">y</var>, <var class="var">z</var> or <var class="var">x</var>, <var class="var">y</var> respectively.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFcurl">curl</a>, <a class="ref" href="#XREFgradient">gradient</a>, <a class="ref" href="#XREFdel2">del2</a>, <a class="ref" href="#XREFdot">dot</a>.
</p></dd></dl>


<a class="anchor" id="XREFcurl"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-curl"><span class="category-def">: </span><span><code class="def-type">[<var class="var">cx</var>, <var class="var">cy</var>, <var class="var">cz</var>, <var class="var">v</var>] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">z</var>, <var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-curl"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-curl-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">cz</var>, <var class="var">v</var>] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-curl-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-curl-2"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>, <var class="var">fz</var>)</code><a class="copiable-link" href="#index-curl-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-curl-3"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(<var class="var">fx</var>, <var class="var">fy</var>)</code><a class="copiable-link" href="#index-curl-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-curl-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">v</var> =</code> <strong class="def-name">curl</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-curl-4"> &para;</a></span></dt>
<dd><p>Calculate curl of vector field given by the arrays <var class="var">fx</var>, <var class="var">fy</var>, and
<var class="var">fz</var> or <var class="var">fx</var>, <var class="var">fy</var> respectively.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">                  / d         d       d         d       d         d     \
curl F(x,y,z)  =  | -- Fz  -  -- Fy,  -- Fx  -  -- Fz,  -- Fy  -  -- Fx |
                  \ dy        dz      dz        dx      dx        dy    /
</pre></div></div>

<p>The coordinates of the vector field can be given by the arguments <var class="var">x</var>,
<var class="var">y</var>, <var class="var">z</var> or <var class="var">x</var>, <var class="var">y</var> respectively.  <var class="var">v</var> calculates the
scalar component of the angular velocity vector in direction of the z-axis
for two-dimensional input.  For three-dimensional input the scalar
rotation is calculated at each grid point in direction of the vector field
at that point.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFdivergence">divergence</a>, <a class="ref" href="#XREFgradient">gradient</a>, <a class="ref" href="#XREFdel2">del2</a>, <a class="ref" href="#XREFcross">cross</a>.
</p></dd></dl>


<a class="anchor" id="XREFdel2"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-del2"><span class="category-def">: </span><span><code class="def-type"><var class="var">L</var> =</code> <strong class="def-name">del2</strong> <code class="def-code-arguments">(<var class="var">M</var>)</code><a class="copiable-link" href="#index-del2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-del2-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">L</var> =</code> <strong class="def-name">del2</strong> <code class="def-code-arguments">(<var class="var">M</var>, <var class="var">h</var>)</code><a class="copiable-link" href="#index-del2-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-del2-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">L</var> =</code> <strong class="def-name">del2</strong> <code class="def-code-arguments">(<var class="var">M</var>, <var class="var">dx</var>, <var class="var">dy</var>, &hellip;)</code><a class="copiable-link" href="#index-del2-2"> &para;</a></span></dt>
<dd>
<p>Calculate the discrete Laplace
operator.
</p>
<p>For a 2-dimensional matrix <var class="var">M</var> this is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">      1    / d^2            d^2         \
L  = --- * | ---  M(x,y) +  ---  M(x,y) |
      4    \ dx^2           dy^2        /
</pre></div></div>

<p>For N-dimensional arrays the sum in parentheses is expanded to include
second derivatives over the additional higher dimensions.
</p>
<p>The spacing between evaluation points may be defined by <var class="var">h</var>, which is a
scalar defining the equidistant spacing in all dimensions.  Alternatively,
the spacing in each dimension may be defined separately by <var class="var">dx</var>,
<var class="var">dy</var>, etc.  A scalar spacing argument defines equidistant spacing,
whereas a vector argument can be used to specify variable spacing.  The
length of the spacing vectors must match the respective dimension of
<var class="var">M</var>.  The default spacing value is 1.
</p>
<p>Dimensions with fewer than 3 data points are skipped.  Boundary points are
calculated from the linear extrapolation of interior points.
</p>
<p>Example: Second derivative of 2*x^3
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">f = @(x) 2*x.^3;
dd = @(x) 12*x;
x = 1:6;
L = 4*del2 (f(x));
assert (L, dd (x));
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgradient">gradient</a>, <a class="ref" href="Finding-Elements-and-Checking-Conditions.html#XREFdiff">diff</a>.
</p></dd></dl>


<a class="anchor" id="XREFfactorial"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-factorial"><span class="category-def">: </span><span><code class="def-type"><var class="var">f</var> =</code> <strong class="def-name">factorial</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-factorial"> &para;</a></span></dt>
<dd><p>Return the factorial of <var class="var">n</var> where <var class="var">n</var> is a real non-negative
integer.
</p>
<p>If <var class="var">n</var> is a scalar, this is equivalent to <code class="code">prod (1:<var class="var">n</var>)</code>.  For
vector or matrix arguments, return the factorial of each element in the
array.
</p>
<p>For non-integers see the generalized factorial function <code class="code">gamma</code>.
Note that the factorial function grows large quite quickly, and even
with double precision values overflow will occur if <var class="var">n</var> &gt; 171.  For
such cases consider <code class="code">gammaln</code>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Sums-and-Products.html#XREFprod">prod</a>, <a class="ref" href="Special-Functions.html#XREFgamma">gamma</a>, <a class="ref" href="Special-Functions.html#XREFgammaln">gammaln</a>.
</p></dd></dl>


<a class="anchor" id="XREFfactor"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-factor"><span class="category-def">: </span><span><code class="def-type"><var class="var">pf</var> =</code> <strong class="def-name">factor</strong> <code class="def-code-arguments">(<var class="var">q</var>)</code><a class="copiable-link" href="#index-factor"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-factor-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">pf</var>, <var class="var">n</var>] =</code> <strong class="def-name">factor</strong> <code class="def-code-arguments">(<var class="var">q</var>)</code><a class="copiable-link" href="#index-factor-1"> &para;</a></span></dt>
<dd><p>Return the prime factorization of <var class="var">q</var>.
</p>
<p>The prime factorization is defined as <code class="code">prod (<var class="var">pf</var>) == <var class="var">q</var></code>
where every element of <var class="var">pf</var> is a prime number.  If <code class="code"><var class="var">q</var> == 1</code>,
return 1.  The output <var class="var">pf</var> is of the same numeric class as the input.
</p>
<p>With two output arguments, return the unique prime factors <var class="var">pf</var> and
their multiplicities.  That is,
<code class="code">prod (<var class="var">pf</var> .^ <var class="var">n</var>) == <var class="var">q</var></code>.
</p>
<p>Implementation Note: If the input <var class="var">q</var> is <code class="code">single</code> or <code class="code">double</code>,
then it must not exceed the corresponding <code class="code">flintmax</code>.  For larger
inputs, cast them to <code class="code">uint64</code> if they&rsquo;re less than 2^64:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">factor (uint64 (18446744073709011493))
   &rArr;     571111    761213  42431951
</pre></div></div>

<p>For even larger inputs, use <code class="code">sym</code> if you have the Symbolic package
installed and loaded:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">factor (sym ('9444733049654361449941'))
   &rArr; (sym)
              1           1
 1099511627689 ⋅8589934669
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFgcd">gcd</a>, <a class="ref" href="#XREFlcm">lcm</a>, <a class="ref" href="Predicates-for-Numeric-Objects.html#XREFisprime">isprime</a>, <a class="ref" href="#XREFprimes">primes</a>.
</p></dd></dl>


<a class="anchor" id="XREFgcd"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-gcd"><span class="category-def">: </span><span><code class="def-type"><var class="var">g</var> =</code> <strong class="def-name">gcd</strong> <code class="def-code-arguments">(<var class="var">a1</var>, <var class="var">a2</var>, &hellip;)</code><a class="copiable-link" href="#index-gcd"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-gcd-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">g</var>, <var class="var">v1</var>, &hellip;] =</code> <strong class="def-name">gcd</strong> <code class="def-code-arguments">(<var class="var">a1</var>, <var class="var">a2</var>, &hellip;)</code><a class="copiable-link" href="#index-gcd-1"> &para;</a></span></dt>
<dd><p>Compute the greatest common divisor of <var class="var">a1</var>, <var class="var">a2</var>, &hellip;.
</p>
<p>All arguments must be the same size or scalar.  For arrays, the greatest common
divisor is calculated for each element individually.  All elements must be
ordinary or Gaussian (complex) integers.  Note that for Gaussian integers, the
gcd is only unique up to a phase factor (multiplication by 1, -1, i, or -i), so
an arbitrary greatest common divisor among the four possible is returned.
</p>
<p>Optional return arguments <var class="var">v1</var>, &hellip;, contain integer vectors such
that,
</p>

<div class="example">
<pre class="example-preformatted"><var class="var">g</var> = <var class="var">v1</var> .* <var class="var">a1</var> + <var class="var">v2</var> .* <var class="var">a2</var> + ...
</pre></div>


<p>Example code:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">gcd ([15, 9], [20, 18])
   &rArr;  5  9
</pre></div></div>

<p>Programming tip: To find the GCD of all the elements of a single array, use
<code class="code">num2cell</code> instead of nested calls or a loop:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">x = [30 42 70 105];    # vector or array of inputs
gcd (num2cell (x) {:})
   &rArr;     1
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlcm">lcm</a>, <a class="ref" href="#XREFfactor">factor</a>, <a class="ref" href="Predicates-for-Numeric-Objects.html#XREFisprime">isprime</a>.
</p></dd></dl>


<a class="anchor" id="XREFlcm"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-lcm"><span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">lcm</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-lcm"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lcm-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">l</var> =</code> <strong class="def-name">lcm</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, &hellip;)</code><a class="copiable-link" href="#index-lcm-1"> &para;</a></span></dt>
<dd><p>Compute the least common multiple of <var class="var">x</var> and <var class="var">y</var>, or of the list of
all arguments.
</p>
<p>All inputs must be of the same size, or scalar.  All elements must be
real integer or Gaussian (complex) integer.  For complex inputs, the result
is unique only up to a phase factor (multiplication by +1, +i, -1, or -i),
and one of the four is returned arbitrarily.
</p>
<p>Example code:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">lcm (5:8, 9:12)
   &rArr;  45  30  77  24
</pre></div></div>

<p>Programming tip: To find the LCM of all the elements of a single array, use
<code class="code">num2cell</code> instead of nested calls or a loop:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">x = 1:10;    # vector or array of inputs
lcm (num2cell (x) {:})
   &rArr;     2520
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfactor">factor</a>, <a class="ref" href="#XREFgcd">gcd</a>, <a class="ref" href="Predicates-for-Numeric-Objects.html#XREFisprime">isprime</a>.
</p></dd></dl>


<a class="anchor" id="XREFrem"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-rem"><span class="category-def">: </span><span><code class="def-type"><var class="var">r</var> =</code> <strong class="def-name">rem</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-rem"> &para;</a></span></dt>
<dd><p>Return the remainder of the division <code class="code"><var class="var">x</var> / <var class="var">y</var></code>.
</p>
<p>The remainder is computed using the expression
</p>
<div class="example">
<pre class="example-preformatted">x - y .* fix (x ./ y)
</pre></div>

<p>An error message is printed if the dimensions of the arguments do not agree,
or if either argument is complex.
</p>
<p>Programming Notes: When calculating with floating point numbers (double,
single), values within a few eps of an integer will be rounded to that
integer before computation for compatibility with <small class="sc">MATLAB</small>.  Any floating
point integers greater than <code class="code">flintmax</code> (2^53 for double) will not compute
correctly.  For larger integer values convert the input to <code class="code">uint64</code> before
calling this function.
</p>
<p>By convention,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">rem (<var class="var">x</var>, 0) = NaN  if <var class="var">x</var> is a floating point variable
rem (<var class="var">x</var>, 0) = 0    if <var class="var">x</var> is an integer variable
rem (<var class="var">x</var>, <var class="var">y</var>)  returns a value with the signbit from <var class="var">x</var>
</pre></div></div>

<p>For the opposite conventions see the <code class="code">mod</code> function.  In general,
<code class="code">rem</code> is best when computing the remainder after division of two
<em class="emph">positive</em> numbers.  For negative numbers, or when the values are
periodic, <code class="code">mod</code> is a better choice.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFmod">mod</a>.
</p></dd></dl>


<a class="anchor" id="XREFmod"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-mod"><span class="category-def">: </span><span><code class="def-type"><var class="var">m</var> =</code> <strong class="def-name">mod</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-mod"> &para;</a></span></dt>
<dd><p>Compute the modulo of <var class="var">x</var> and <var class="var">y</var>.
</p>
<p>Conceptually this is given by
</p>
<div class="example">
<pre class="example-preformatted">x - y .* floor (x ./ y)
</pre></div>

<p>and is written such that the correct modulus is returned for integer types.
This function handles negative values correctly.  That is,
<code class="code">mod&nbsp;(-1,&nbsp;3)</code><!-- /@w --> is 2, not -1, as <code class="code">rem&nbsp;(-1,&nbsp;3)</code><!-- /@w --> returns.
</p>
<p>An error results if the dimensions of the arguments do not agree, or if
either of the arguments is complex.
</p>
<p>Programming Notes: When calculating with floating point numbers (double,
single), values within a few eps of an integer will be rounded to that
integer before computation for compatibility with <small class="sc">MATLAB</small>.  Any floating
point integers greater than <code class="code">flintmax</code> (2^53 for double) will not compute
correctly.  For larger integer values convert the input to <code class="code">uint64</code> before
calling this function.
</p>
<p>By convention,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">mod (<var class="var">x</var>, 0) = <var class="var">x</var>
mod (<var class="var">x</var>, <var class="var">y</var>)      returns a value with the signbit from <var class="var">y</var>
</pre></div></div>

<p>For the opposite conventions see the <code class="code">rem</code> function.  In general,
<code class="code">mod</code> is a better choice than <code class="code">rem</code> when any of the inputs are
negative numbers or when the values are periodic.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrem">rem</a>.
</p></dd></dl>


<a class="anchor" id="XREFprimes"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-primes"><span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">primes</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-primes"> &para;</a></span></dt>
<dd><p>Return all primes up to <var class="var">n</var>.
</p>
<p>The output data class (double, single, uint32, etc.) is the same as the
input class of <var class="var">n</var>.  The algorithm used is the Sieve of Eratosthenes.
</p>
<p>Note: For a specific number <var class="var">n</var> of primes, call
<code class="code">list_primes (<var class="var">n</var>)</code>.  Alternatively, call
<code class="code">primes (<var class="var">n</var>*log (<var class="var">k</var>*<var class="var">n</var>))(1:<var class="var">n</var>)</code> where <var class="var">k</var> is
about 5 or 6.  This works because the distance from one prime to the next is
proportional to the logarithm of the prime, on average.  On integrating,
there are about <var class="var">n</var> primes less than <code class="code"><var class="var">n</var> * log (5*<var class="var">n</var>)</code>.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlist_005fprimes">list_primes</a>, <a class="ref" href="Predicates-for-Numeric-Objects.html#XREFisprime">isprime</a>.
</p></dd></dl>


<a class="anchor" id="XREFlist_005fprimes"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-list_005fprimes"><span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">list_primes</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-list_005fprimes"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-list_005fprimes-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">list_primes</strong> <code class="def-code-arguments">(<var class="var">n</var>)</code><a class="copiable-link" href="#index-list_005fprimes-1"> &para;</a></span></dt>
<dd><p>List the first <var class="var">n</var> primes.
</p>
<p>If <var class="var">n</var> is unspecified, the first 25 primes are listed.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFprimes">primes</a>, <a class="ref" href="Predicates-for-Numeric-Objects.html#XREFisprime">isprime</a>.
</p></dd></dl>


<a class="anchor" id="XREFsign"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-sign"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sign</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sign"> &para;</a></span></dt>
<dd><p>Compute the <em class="dfn">signum</em> function.
</p>
<p>This is defined as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">           -1, x &lt; 0;
sign (x) =  0, x = 0;
            1, x &gt; 0.
</pre></div></div>


<p>For complex arguments, <code class="code">sign</code> returns <code class="code">x ./ abs (<var class="var">x</var>)</code>.
</p>
<p>Note that <code class="code">sign (-0.0)</code> is 0.  Although IEEE 754 floating point
allows zero to be signed, 0.0 and -0.0 compare equal.  If you must test
whether zero is signed, use the <code class="code">signbit</code> function.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsignbit">signbit</a>.
</p></dd></dl>


<a class="anchor" id="XREFsignbit"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-signbit"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">signbit</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-signbit"> &para;</a></span></dt>
<dd><p>Return logical true if the value of <var class="var">x</var> has its sign bit set and false
otherwise.
</p>
<p>This behavior is consistent with the other logical functions.
See <a class="xref" href="Logical-Values.html">Logical Values</a>.  The behavior differs from the C language function
which returns nonzero if the sign bit is set.
</p>
<p>This is not the same as <code class="code">x &lt; 0.0</code>, because IEEE 754 floating point
allows zero to be signed.  The comparison <code class="code">-0.0 &lt; 0.0</code> is false,
but <code class="code">signbit (-0.0)</code> will return a nonzero value.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsign">sign</a>.
</p></dd></dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Special-Functions.html">Special Functions</a>, Previous: <a href="Sums-and-Products.html">Sums and Products</a>, Up: <a href="Arithmetic.html">Arithmetic</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
