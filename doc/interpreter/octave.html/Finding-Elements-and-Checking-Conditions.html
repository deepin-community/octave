<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Finding Elements and Checking Conditions (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Finding Elements and Checking Conditions (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Finding Elements and Checking Conditions (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Matrix-Manipulation.html" rel="up" title="Matrix Manipulation">
<link href="Rearranging-Matrices.html" rel="next" title="Rearranging Matrices">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Finding-Elements-and-Checking-Conditions">
<div class="nav-panel">
<p>
Next: <a href="Rearranging-Matrices.html" accesskey="n" rel="next">Rearranging Matrices</a>, Up: <a href="Matrix-Manipulation.html" accesskey="u" rel="up">Matrix Manipulation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Finding-Elements-and-Checking-Conditions-1"><span>16.1 Finding Elements and Checking Conditions<a class="copiable-link" href="#Finding-Elements-and-Checking-Conditions-1"> &para;</a></span></h3>

<p>The functions <code class="code">any</code> and <code class="code">all</code> are useful for determining
whether any or all of the elements of a matrix satisfy some condition.
The <code class="code">find</code> function is also useful in determining which elements of
a matrix meet a specified condition.
</p>
<a class="anchor" id="XREFany"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-any"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">any</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-any"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-any-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">any</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-any-1"> &para;</a></span></dt>
<dd><p>For a vector argument, return true (logical 1) if any element of the vector
is nonzero.
</p>
<p>For a matrix argument, return a row vector of logical ones and zeros with each
element indicating whether any of the elements of the corresponding column of
the matrix are nonzero.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">any (eye (2, 4))
 &rArr; [ 1, 1, 0, 0 ]
</pre></div></div>

<p>If the optional argument <var class="var">dim</var> is supplied, work along dimension <var class="var">dim</var>.
For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">any (eye (2, 4), 2)
 &rArr; [ 1; 1 ]
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFall">all</a>.
</p></dd></dl>


<a class="anchor" id="XREFall"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-all"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">all</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-all"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-all-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">all</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-all-1"> &para;</a></span></dt>
<dd><p>For a vector argument, return true (logical 1) if all elements of the vector
are nonzero.
</p>
<p>For a matrix argument, return a row vector of logical ones and zeros with each
element indicating whether all of the elements of the corresponding column of
the matrix are nonzero.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">all ([2, 3; 1, 0])
    &rArr; [ 1, 0 ]
</pre></div></div>

<p>If the optional argument <var class="var">dim</var> is supplied, work along dimension <var class="var">dim</var>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFany">any</a>.
</p></dd></dl>


<p>Since the comparison operators (see <a class="pxref" href="Comparison-Ops.html">Comparison Operators</a>) return matrices
of ones and zeros, it is easy to test a matrix for many things, not just
whether the elements are nonzero.  For example,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">all (all (rand (5) &lt; 0.9))
     &rArr; 0
</pre></div></div>

<p>tests a random 5 by 5 matrix to see if all of its elements are less
than 0.9.
</p>
<p>Note that in conditional contexts (like the test clause of <code class="code">if</code> and
<code class="code">while</code> statements) Octave treats the test as if you had typed
<code class="code">all (all (condition))</code>.
</p>
<a class="anchor" id="XREFxor"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-xor"><span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">xor</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-xor"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-xor-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">z</var> =</code> <strong class="def-name">xor</strong> <code class="def-code-arguments">(<var class="var">x1</var>, <var class="var">x2</var>, &hellip;)</code><a class="copiable-link" href="#index-xor-1"> &para;</a></span></dt>
<dd><p>Return the <em class="dfn">exclusive or</em> of <var class="var">x</var> and <var class="var">y</var>.
</p>
<p>For boolean expressions <var class="var">x</var> and <var class="var">y</var>,
<code class="code">xor (<var class="var">x</var>, <var class="var">y</var>)</code> is true if and only if one of <var class="var">x</var> or
<var class="var">y</var> is true.  Otherwise, if <var class="var">x</var> and <var class="var">y</var> are both true or both
false, <code class="code">xor</code> returns false.
</p>
<p>The truth table for the xor operation is
</p>
<table class="multitable">
<tbody><tr><td width="44%"></td><td width="3%"><var class="var">x</var></td><td width="5%"><var class="var">y</var></td><td width="3%"><var class="var">z</var></td><td width="44%"></td></tr>
<tr><td width="44%"></td><td width="3%">-</td><td width="5%">-</td><td width="3%">-</td><td width="44%"></td></tr>
<tr><td width="44%"></td><td width="3%">0</td><td width="5%">0</td><td width="3%">0</td><td width="44%"></td></tr>
<tr><td width="44%"></td><td width="3%">1</td><td width="5%">0</td><td width="3%">1</td><td width="44%"></td></tr>
<tr><td width="44%"></td><td width="3%">0</td><td width="5%">1</td><td width="3%">1</td><td width="44%"></td></tr>
<tr><td width="44%"></td><td width="3%">1</td><td width="5%">1</td><td width="3%">0</td><td width="44%"></td></tr>
</tbody>
</table>

<p>If more than two arguments are given the xor operation is applied
cumulatively from left to right:
</p>
<div class="example">
<pre class="example-preformatted">(...((x1 XOR x2) XOR x3) XOR ...)
</pre></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="Element_002dby_002delement-Boolean-Operators.html#XREFand">and</a>, <a class="ref" href="Element_002dby_002delement-Boolean-Operators.html#XREFor">or</a>, <a class="ref" href="Element_002dby_002delement-Boolean-Operators.html#XREFnot">not</a>.
</p></dd></dl>


<a class="anchor" id="XREFdiff"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-diff"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">diff</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-diff"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-diff-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">diff</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-diff-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-diff-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">diff</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">k</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-diff-2"> &para;</a></span></dt>
<dd><p>If <var class="var">x</var> is a vector of length <em class="math">n</em>, <code class="code">diff&nbsp;(<var class="var">x</var>)</code><!-- /@w --> is the
vector of first differences
 <var class="var">x</var>(2) - <var class="var">x</var>(1), &hellip;, <var class="var">x</var>(n) - <var class="var">x</var>(n-1).
</p>
<p>If <var class="var">x</var> is a matrix, <code class="code">diff&nbsp;(<var class="var">x</var>)</code><!-- /@w --> is the matrix of column
differences along the first non-singleton dimension.
</p>
<p>The second argument is optional.  If supplied,
<code class="code">diff&nbsp;(<var class="var">x</var>,&nbsp;<var class="var">k</var>)</code><!-- /@w -->, where <var class="var">k</var> is a non-negative integer,
returns the <var class="var">k</var>-th differences.  It is possible that <var class="var">k</var> is larger
than the first non-singleton dimension of the matrix.  In this case,
<code class="code">diff</code> continues to take the differences along the next
non-singleton dimension.
</p>
<p>The dimension along which to take the difference can be explicitly
stated with the optional variable <var class="var">dim</var>.  In this case the
<var class="var">k</var>-th order differences are calculated along this dimension.
In the case where <var class="var">k</var> exceeds <code class="code">size&nbsp;(<var class="var">x</var>,&nbsp;<var class="var">dim</var>)</code><!-- /@w -->
an empty matrix is returned.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Rearranging-Matrices.html#XREFsort">sort</a>, <a class="ref" href="Short_002dcircuit-Boolean-Operators.html#XREFmerge">merge</a>.
</p></dd></dl>


<a class="anchor" id="XREFisinf"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-isinf"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">isinf</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-isinf"> &para;</a></span></dt>
<dd><p>Return a logical array which is true where the elements of <var class="var">x</var> are
infinite and false where they are not.
</p>
<p>For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">isinf ([13, Inf, NA, NaN])
      &rArr; [ 0, 1, 0, 0 ]
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisfinite">isfinite</a>, <a class="ref" href="#XREFisnan">isnan</a>, <a class="ref" href="Missing-Data.html#XREFisna">isna</a>.
</p></dd></dl>


<a class="anchor" id="XREFisnan"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-isnan"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">isnan</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-isnan"> &para;</a></span></dt>
<dd><p>Return a logical array which is true where the elements of <var class="var">x</var> are
NaN values and false where they are not.
</p>
<p>NA values are also considered NaN values.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">isnan ([13, Inf, NA, NaN])
      &rArr; [ 0, 0, 1, 1 ]
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="Missing-Data.html#XREFisna">isna</a>, <a class="ref" href="#XREFisinf">isinf</a>, <a class="ref" href="#XREFisfinite">isfinite</a>.
</p></dd></dl>


<a class="anchor" id="XREFisfinite"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-isfinite"><span class="category-def">: </span><span><code class="def-type"><var class="var">tf</var> =</code> <strong class="def-name">isfinite</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-isfinite"> &para;</a></span></dt>
<dd><p>Return a logical array which is true where the elements of <var class="var">x</var> are
finite values and false where they are not.
</p>
<p>For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">isfinite ([13, Inf, NA, NaN])
     &rArr; [ 1, 0, 0, 0 ]
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFisinf">isinf</a>, <a class="ref" href="#XREFisnan">isnan</a>, <a class="ref" href="Missing-Data.html#XREFisna">isna</a>.
</p></dd></dl>


<a class="anchor" id="XREFcommon_005fsize"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-common_005fsize"><span class="category-def">: </span><span><code class="def-type">[<var class="var">err</var>, <var class="var">yi</var>, &hellip;] =</code> <strong class="def-name">common_size</strong> <code class="def-code-arguments">(<var class="var">xi</var>, &hellip;)</code><a class="copiable-link" href="#index-common_005fsize"> &para;</a></span></dt>
<dd><p>Determine if all input arguments are either scalar or of common size.
</p>
<p>If true, <var class="var">err</var> is zero, and <var class="var">yi</var> is a matrix of the common size
with all entries equal to <var class="var">xi</var> if this is a scalar or <var class="var">xi</var>
otherwise.  If the inputs cannot be brought to a common size, <var class="var">err</var> is
1, and <var class="var">yi</var> is <var class="var">xi</var>.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[err, a, b] = common_size ([1 2; 3 4], 5)
     &rArr; err = 0
     &rArr; a = [ 1, 2; 3, 4 ]
     &rArr; b = [ 5, 5; 5, 5 ]
</pre></div></div>

<p>This is useful for implementing functions where arguments can either be
scalars or of common size.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Object-Sizes.html#XREFsize">size</a>, <a class="ref" href="Object-Sizes.html#XREFsize_005fequal">size_equal</a>, <a class="ref" href="Object-Sizes.html#XREFnumel">numel</a>, <a class="ref" href="Object-Sizes.html#XREFndims">ndims</a>.
</p></dd></dl>


<a class="anchor" id="XREFfind"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-find"><span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-find"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-find-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-find-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-find-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">direction</var>)</code><a class="copiable-link" href="#index-find-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-find-3"><span class="category-def">: </span><span><code class="def-type">[i, j] =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-find-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-find-4"><span class="category-def">: </span><span><code class="def-type">[i, j, v] =</code> <strong class="def-name">find</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-find-4"> &para;</a></span></dt>
<dd><p>Return a vector of indices of nonzero elements of a matrix, as a row if
<var class="var">x</var> is a row vector or as a column otherwise.
</p>
<p>To obtain a single index for each matrix element, Octave pretends that the
columns of a matrix form one long vector (like Fortran arrays are stored).
For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">find (eye (2))
  &rArr; [ 1; 4 ]
</pre></div></div>

<p>If two inputs are given, <var class="var">n</var> indicates the maximum number of elements to
find from the beginning of the matrix or vector.
</p>
<p>If three inputs are given, <var class="var">direction</var> should be one of
<code class="code">&quot;first&quot;</code> or <code class="code">&quot;last&quot;</code>, requesting only the first or last
<var class="var">n</var> indices, respectively.  However, the indices are always returned in
ascending order.
</p>
<p>If two outputs are requested, <code class="code">find</code> returns the row and column
indices of nonzero elements of a matrix.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[i, j] = find (2 * eye (2))
    &rArr; i = [ 1; 2 ]
    &rArr; j = [ 1; 2 ]
</pre></div></div>

<p>If three outputs are requested, <code class="code">find</code> also returns a vector
containing the nonzero values.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[i, j, v] = find (3 * eye (2))
       &rArr; i = [ 1; 2 ]
       &rArr; j = [ 1; 2 ]
       &rArr; v = [ 3; 3 ]
</pre></div></div>

<p>If <var class="var">x</var> is a multi-dimensional array of size m x n x p x &hellip;, <var class="var">j</var>
contains the column locations as if <var class="var">x</var> was flattened into a
two-dimensional matrix of size m x (n + p + &hellip;).
</p>
<p>Note that this function is particularly useful for sparse matrices, as
it extracts the nonzero elements as vectors, which can then be used to
create the original matrix.  For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">sz = size (a);
[i, j, v] = find (a);
b = sparse (i, j, v, sz(1), sz(2));
</pre></div></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="Information.html#XREFnonzeros">nonzeros</a>.
</p></dd></dl>


<a class="anchor" id="XREFlookup"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-lookup"><span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">lookup</strong> <code class="def-code-arguments">(<var class="var">table</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-lookup"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lookup-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">idx</var> =</code> <strong class="def-name">lookup</strong> <code class="def-code-arguments">(<var class="var">table</var>, <var class="var">y</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-lookup-1"> &para;</a></span></dt>
<dd><p>Lookup values in a <strong class="strong">sorted</strong> table.
</p>
<p>This function is usually used as a prelude to interpolation.
</p>
<p>If table is increasing, of length N and <code class="code">idx = lookup (table, y)</code>, then
<code class="code">table(idx(i)) &lt;= y(i) &lt; table(idx(i+1))</code> for all <code class="code">y(i)</code> within the
table.  If <code class="code">y(i) &lt; table(1)</code> then <code class="code">idx(i)</code> is 0.  If
<code class="code">y(i) &gt;= table(end)</code> or <code class="code">isnan (y(i))</code> then <code class="code">idx(i)</code> is N.
</p>
<p>If the table is decreasing, then the tests are reversed.  For non-strictly
monotonic tables, empty intervals are always skipped.  The result is undefined
if <var class="var">table</var> is not monotonic, or if <var class="var">table</var> contains a NaN.
</p>
<p>The complexity of the lookup is O(M*log(N)) where M is the size of <var class="var">y</var>.
In the special case when <var class="var">y</var> is also sorted, the complexity is
O(min (M*log(N), M+N)).
</p>
<p><var class="var">table</var> and <var class="var">y</var> can also be cell arrays of strings (or <var class="var">y</var> can be a
single string).  In this case, string lookup is performed using lexicographical
comparison.
</p>
<p>If <var class="var">opts</var> is specified, it must be a string with letters indicating
additional options.
</p>
<dl class="table">
<dt><code class="code">m</code></dt>
<dd><p>Match.  <code class="code">table(idx(i)) == y(i)</code> if <code class="code">y(i)</code> occurs in table;
otherwise, <code class="code">idx(i)</code> is zero.
</p>
</dd>
<dt><code class="code">b</code></dt>
<dd><p>Boolean.  <code class="code">idx(i)</code> is a logical 1 or 0, indicating whether <code class="code">y(i)</code>
is contained in table or not.
</p>
</dd>
<dt><code class="code">l</code></dt>
<dd><p>Left.  For numeric lookups the leftmost subinterval shall be extended to
minus infinity (i.e., all indices at least 1).
</p>
</dd>
<dt><code class="code">r</code></dt>
<dd><p>Right.  For numeric lookups the rightmost subinterval shall be extended to
infinity (i.e., all indices at most N-1).
</p></dd>
</dl>

<p><strong class="strong">Note</strong>: If <var class="var">table</var> is not sorted the results from <code class="code">lookup</code>
will be unpredictable.
</p></dd></dl>


<p>If you wish to check if a variable exists at all, instead of properties
its elements may have, consult <a class="ref" href="Status-of-Variables.html">Status of Variables</a>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Rearranging-Matrices.html">Rearranging Matrices</a>, Up: <a href="Matrix-Manipulation.html">Matrix Manipulation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
