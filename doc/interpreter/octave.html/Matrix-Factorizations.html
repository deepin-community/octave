<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Matrix Factorizations (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Matrix Factorizations (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Matrix Factorizations (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Linear-Algebra.html" rel="up" title="Linear Algebra">
<link href="Functions-of-a-Matrix.html" rel="next" title="Functions of a Matrix">
<link href="Basic-Matrix-Functions.html" rel="prev" title="Basic Matrix Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Matrix-Factorizations">
<div class="nav-panel">
<p>
Next: <a href="Functions-of-a-Matrix.html" accesskey="n" rel="next">Functions of a Matrix</a>, Previous: <a href="Basic-Matrix-Functions.html" accesskey="p" rel="prev">Basic Matrix Functions</a>, Up: <a href="Linear-Algebra.html" accesskey="u" rel="up">Linear Algebra</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Matrix-Factorizations-1"><span>18.3 Matrix Factorizations<a class="copiable-link" href="#Matrix-Factorizations-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-matrix-factorizations"></a>

<a class="anchor" id="XREFchol"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-chol"><span class="category-def">: </span><span><code class="def-type"><var class="var">R</var> =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-chol"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-chol-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, <var class="var">p</var>] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-chol-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-chol-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, <var class="var">p</var>, <var class="var">Q</var>] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-chol-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-chol-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, <var class="var">p</var>, <var class="var">Q</var>] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(<var class="var">A</var>, &quot;vector&quot;)</code><a class="copiable-link" href="#index-chol-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-chol-4"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, &hellip;] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(&hellip;, &quot;lower&quot;)</code><a class="copiable-link" href="#index-chol-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-chol-5"><span class="category-def">: </span><span><code class="def-type">[<var class="var">R</var>, &hellip;] =</code> <strong class="def-name">chol</strong> <code class="def-code-arguments">(&hellip;, &quot;upper&quot;)</code><a class="copiable-link" href="#index-chol-5"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Cholesky-factorization"></a>
<p>Compute the upper Cholesky&nbsp;factor, <var class="var">R</var>, of the real symmetric
or complex Hermitian positive definite matrix <var class="var">A</var>.
</p>
<p>The upper Cholesky&nbsp;factor <var class="var">R</var> is computed by using the upper
triangular part of matrix <var class="var">A</var> and is defined by
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">R</var>' * <var class="var">R</var> = <var class="var">A</var>.
</pre></div>


<p>Calling <code class="code">chol</code> using the optional <code class="code">&quot;upper&quot;</code> flag has the
same behavior.  In contrast, using the optional <code class="code">&quot;lower&quot;</code> flag,
<code class="code">chol</code> returns the lower triangular factorization, computed by using
the lower triangular part of matrix <var class="var">A</var>, such that
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">L</var> * <var class="var">L</var>' = <var class="var">A</var>.
</pre></div>


<p>Called with one output argument <code class="code">chol</code> fails if matrix <var class="var">A</var> is
not positive definite.  Note that if matrix <var class="var">A</var> is not real symmetric
or complex Hermitian then the lower triangular part is considered to be
the (complex conjugate) transpose of the upper triangular part, or vice
versa, given the <code class="code">&quot;lower&quot;</code> flag.
</p>
<p>Called with two or more output arguments <var class="var">p</var> flags whether the matrix
<var class="var">A</var> was positive definite and <code class="code">chol</code> does not fail.  A zero value
of <var class="var">p</var> indicates that matrix <var class="var">A</var> is positive definite and <var class="var">R</var>
gives the factorization.  Otherwise, <var class="var">p</var> will have a positive value.
</p>
<p>If called with three output arguments matrix <var class="var">A</var> must be sparse and
a sparsity preserving row/column permutation is applied to matrix <var class="var">A</var>
prior to the factorization.  That is <var class="var">R</var> is the factorization of
<code class="code"><var class="var">A</var>(<var class="var">Q</var>,<var class="var">Q</var>)</code> such that
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">R</var>' * <var class="var">R</var> = <var class="var">Q</var>' * <var class="var">A</var> * <var class="var">Q</var>.
</pre></div>


<p>The sparsity preserving permutation is generally returned as a matrix.
However, given the optional flag <code class="code">&quot;vector&quot;</code>, <var class="var">Q</var> will be
returned as a vector such that
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">R</var>' * <var class="var">R</var> = <var class="var">A</var>(<var class="var">Q</var>, <var class="var">Q</var>).
</pre></div>


<p>In general the lower triangular factorization is significantly faster for
sparse matrices.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>, <a class="ref" href="Iterative-Techniques.html#XREFichol">ichol</a>, <a class="ref" href="#XREFcholinv">cholinv</a>, <a class="ref" href="#XREFchol2inv">chol2inv</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>, <a class="ref" href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFcholinv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cholinv"><span class="category-def">: </span><span><code class="def-type"><var class="var">Ainv</var> =</code> <strong class="def-name">cholinv</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-cholinv"> &para;</a></span></dt>
<dd><p>Compute the inverse of the symmetric positive definite matrix <var class="var">A</var> using
the Cholesky&nbsp;factorization.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFchol2inv">chol2inv</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFinv">inv</a>.
</p></dd></dl>


<a class="anchor" id="XREFchol2inv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-chol2inv"><span class="category-def">: </span><span><code class="def-type"><var class="var">Ainv</var> =</code> <strong class="def-name">chol2inv</strong> <code class="def-code-arguments">(<var class="var">R</var>)</code><a class="copiable-link" href="#index-chol2inv"> &para;</a></span></dt>
<dd><p>Invert a symmetric, positive definite square matrix from its Cholesky
decomposition, <var class="var">R</var>.
</p>
<p>Note that <var class="var">R</var> should be an upper-triangular matrix with positive diagonal
elements.  <code class="code">chol2inv (<var class="var">U</var>)</code> provides <code class="code">inv (<var class="var">R</var>'*<var class="var">R</var>)</code> but
is much faster than using <code class="code">inv</code>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholinv">cholinv</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFinv">inv</a>.
</p></dd></dl>


<a class="anchor" id="XREFcholupdate"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cholupdate"><span class="category-def">: </span><span><code class="def-type">[<var class="var">R1</var>, <var class="var">info</var>] =</code> <strong class="def-name">cholupdate</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">u</var>, <var class="var">op</var>)</code><a class="copiable-link" href="#index-cholupdate"> &para;</a></span></dt>
<dd><p>Update or downdate a Cholesky&nbsp;factorization.
</p>
<p>Given an upper triangular matrix <var class="var">R</var> and a column vector <var class="var">u</var>,
attempt to determine another upper triangular matrix <var class="var">R1</var> such that
</p>
<ul class="itemize mark-bullet">
<li><var class="var">R1</var>&rsquo;*<var class="var">R1</var> = <var class="var">R</var>&rsquo;*<var class="var">R</var> + <var class="var">u</var>*<var class="var">u</var>&rsquo;
if <var class="var">op</var> is <code class="code">&quot;+&quot;</code>

</li><li><var class="var">R1</var>&rsquo;*<var class="var">R1</var> = <var class="var">R</var>&rsquo;*<var class="var">R</var> - <var class="var">u</var>*<var class="var">u</var>&rsquo;
if <var class="var">op</var> is <code class="code">&quot;-&quot;</code>
</li></ul>

<p>If <var class="var">op</var> is <code class="code">&quot;-&quot;</code>, <var class="var">info</var> is set to
</p>
<ul class="itemize mark-bullet">
<li>0 if the downdate was successful,

</li><li>1 if <var class="var">R</var>&rsquo;*<var class="var">R</var> - <var class="var">u</var>*<var class="var">u</var>&rsquo; is not positive definite,

</li><li>2 if <var class="var">R</var> is singular.
</li></ul>

<p>If <var class="var">info</var> is not present, an error message is printed in cases 1 and 2.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>, <a class="ref" href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFcholinsert"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cholinsert"><span class="category-def">: </span><span><code class="def-type"><var class="var">R1</var> =</code> <strong class="def-name">cholinsert</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">j</var>, <var class="var">u</var>)</code><a class="copiable-link" href="#index-cholinsert"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-cholinsert-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">R1</var>, <var class="var">info</var>] =</code> <strong class="def-name">cholinsert</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">j</var>, <var class="var">u</var>)</code><a class="copiable-link" href="#index-cholinsert-1"> &para;</a></span></dt>
<dd><p>Update a Cholesky factorization given a row or column to insert in the
original factored matrix.
</p>
<p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var class="var">A</var>&nbsp;=&nbsp;<var class="var">R</var>&rsquo;*<var class="var">R</var><!-- /@w -->, <var class="var">R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of
<var class="var">A1</var>, where A1(p,p)&nbsp;=&nbsp;A<!-- /@w -->, A1(:,j)&nbsp;=&nbsp;A1(j,:)&rsquo;&nbsp;=&nbsp;u<!-- /@w --> and
p&nbsp;=&nbsp;[1:j-1,j+1:n+1]<!-- /@w -->.  u(j)<!-- /@w --> should be positive.
</p>
<p>On return, <var class="var">info</var> is set to
</p>
<ul class="itemize mark-bullet">
<li>0 if the insertion was successful,

</li><li>1 if <var class="var">A1</var> is not positive definite,

</li><li>2 if <var class="var">R</var> is singular.
</li></ul>

<p>If <var class="var">info</var> is not present, an error message is printed in cases 1 and 2.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>, <a class="ref" href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFcholdelete"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-choldelete"><span class="category-def">: </span><span><code class="def-type"><var class="var">R1</var> =</code> <strong class="def-name">choldelete</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">j</var>)</code><a class="copiable-link" href="#index-choldelete"> &para;</a></span></dt>
<dd><p>Update a Cholesky factorization given a row or column to delete from the
original factored matrix.
</p>
<p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var class="var">A</var>&nbsp;=&nbsp;<var class="var">R</var>&rsquo;*<var class="var">R</var><!-- /@w -->, <var class="var">R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of A(p,p)<!-- /@w -->, where
p&nbsp;=&nbsp;[1:j-1,j+1:n+1]<!-- /@w -->.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholshift">cholshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFcholshift"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-cholshift"><span class="category-def">: </span><span><code class="def-type"><var class="var">R1</var> =</code> <strong class="def-name">cholshift</strong> <code class="def-code-arguments">(<var class="var">R</var>, <var class="var">i</var>, <var class="var">j</var>)</code><a class="copiable-link" href="#index-cholshift"> &para;</a></span></dt>
<dd><p>Update a Cholesky factorization given a range of columns to shift in the
original factored matrix.
</p>
<p>Given a Cholesky&nbsp;factorization of a real symmetric or complex Hermitian
positive definite matrix <var class="var">A</var>&nbsp;=&nbsp;<var class="var">R</var>&rsquo;*<var class="var">R</var><!-- /@w -->, <var class="var">R</var>&nbsp;upper
triangular, return the Cholesky&nbsp;factorization of
<var class="var">A</var>(p,p)<!-- /@w -->, where p<!-- /@w --> is the permutation <br>
<code class="code">p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var class="var">i</var>&nbsp;&lt;&nbsp;<var class="var">j</var><!-- /@w --> <br>
 or <br>
<code class="code">p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var class="var">j</var>&nbsp;&lt;&nbsp;<var class="var">i</var><!-- /@w -->.  <br>
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFcholinsert">cholinsert</a>, <a class="ref" href="#XREFcholdelete">choldelete</a>.
</p></dd></dl>


<a class="anchor" id="XREFhess"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-hess"><span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">hess</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-hess"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-hess-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">P</var>, <var class="var">H</var>] =</code> <strong class="def-name">hess</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-hess-1"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Hessenberg-decomposition"></a>
<p>Compute the Hessenberg decomposition of the matrix <var class="var">A</var>.
</p>
<p>The Hessenberg decomposition is
<code class="code"><var class="var">P</var> * <var class="var">H</var> * <var class="var">P</var>' = <var class="var">A</var></code> where <var class="var">P</var> is a square
unitary matrix (<code class="code"><var class="var">P</var>' * <var class="var">P</var> = I</code>, using complex-conjugate
transposition) and <var class="var">H</var> is upper Hessenberg
(<code class="code"><var class="var">H</var>(i, j) = 0 forall i &gt; j+1)</code>.
</p>
<p>The Hessenberg decomposition is usually used as the first step in an
eigenvalue computation, but has other applications as well
(see Golub, Nash, and Van Loan,
IEEE Transactions on Automatic Control, 1979).
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>.
</p></dd></dl>


<a class="anchor" id="XREFlu"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-lu"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-lu"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lu-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-lu-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lu-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">Q</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-lu-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lu-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">Q</var>, <var class="var">R</var>] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-lu-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lu-4"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(<var class="var">S</var>, <var class="var">thresh</var>)</code><a class="copiable-link" href="#index-lu-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lu-5"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-lu-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-lu-6"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">lu</strong> <code class="def-code-arguments">(&hellip;, &quot;vector&quot;)</code><a class="copiable-link" href="#index-lu-6"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-LU-decomposition"></a>
<p>Compute the LU&nbsp;decomposition of <var class="var">A</var>.
</p>
<p>If <var class="var">A</var> is full then subroutines from <small class="sc">LAPACK</small> are used, and if
<var class="var">A</var> is sparse then <small class="sc">UMFPACK</small> is used.
</p>
<p>The result is returned in a permuted form, according to the optional return
value <var class="var">P</var>.  For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>,
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>] = lu (<var class="var">A</var>)
</pre></div>

<p>returns
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">L =

  1.00000  0.00000
  0.33333  1.00000

U =

  3.00000  4.00000
  0.00000  0.66667

P =

  0  1
  1  0
</pre></div></div>

<p>The matrix is not required to be square.
</p>
<p>When called with two or three output arguments and a sparse input matrix,
<code class="code">lu</code> does not attempt to perform sparsity preserving column permutations.
Called with a fourth output argument, the sparsity preserving column
transformation <var class="var">Q</var> is returned, such that
<code class="code"><var class="var">P</var> * <var class="var">A</var> * <var class="var">Q</var> = <var class="var">L</var> * <var class="var">U</var></code>.  This is the
<strong class="strong">preferred</strong> way to call <code class="code">lu</code> with sparse input matrices.
</p>
<p>Called with a fifth output argument and a sparse input matrix, <code class="code">lu</code>
attempts to use a scaling factor <var class="var">R</var> on the input matrix such that
<code class="code"><var class="var">P</var> * (<var class="var">R</var> \ <var class="var">A</var>) * <var class="var">Q</var> = <var class="var">L</var> * <var class="var">U</var></code>.
This typically leads to a sparser and more stable factorization.
</p>
<p>An additional input argument <var class="var">thresh</var> that defines the pivoting
threshold can be given.  <var class="var">thresh</var> can be a scalar, in which case
it defines the <small class="sc">UMFPACK</small> pivoting tolerance for both symmetric and
unsymmetric cases.  If <var class="var">thresh</var> is a 2-element vector, then the first
element defines the pivoting tolerance for the unsymmetric <small class="sc">UMFPACK</small>
pivoting strategy and the second for the symmetric strategy.  By default,
the values defined by <code class="code">spparms</code> are used ([0.1, 0.001]).
</p>
<p>Given the string argument <code class="code">&quot;vector&quot;</code>, <code class="code">lu</code> returns the values
of <var class="var">P</var> and <var class="var">Q</var> as vector values, such that for full matrix,
<code class="code"><var class="var">A</var>(<var class="var">P</var>,:) = <var class="var">L</var> * <var class="var">U</var></code>, and <code class="code"><var class="var">R</var>(<var class="var">P</var>,:)
* <var class="var">A</var>(:,<var class="var">Q</var>) = <var class="var">L</var> * <var class="var">U</var></code>.
</p>
<p>With two output arguments, returns the permuted forms of the upper and
lower triangular matrices, such that <code class="code"><var class="var">A</var> = <var class="var">L</var> * <var class="var">U</var></code>.
With one output argument <var class="var">y</var>, then the matrix returned by the
<small class="sc">LAPACK</small> routines is returned.  If the input matrix is sparse then the
matrix <var class="var">L</var> is embedded into <var class="var">U</var> to give a return value similar to
the full case.  For both full and sparse matrices, <code class="code">lu</code> loses the
permutation information.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFluupdate">luupdate</a>, <a class="ref" href="Iterative-Techniques.html#XREFilu">ilu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>.
</p></dd></dl>


<a class="anchor" id="XREFluupdate"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-luupdate"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>] =</code> <strong class="def-name">luupdate</strong> <code class="def-code-arguments">(<var class="var">L</var>, <var class="var">U</var>, <var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-luupdate"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-luupdate-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>] =</code> <strong class="def-name">luupdate</strong> <code class="def-code-arguments">(<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-luupdate-1"> &para;</a></span></dt>
<dd><p>Given an LU&nbsp;factorization of a real or complex matrix
<var class="var">A</var>&nbsp;=&nbsp;<var class="var">L</var>*<var class="var">U</var><!-- /@w -->, <var class="var">L</var>&nbsp;lower unit trapezoidal and
<var class="var">U</var>&nbsp;upper trapezoidal, return the LU&nbsp;factorization
of <var class="var">A</var>&nbsp;+&nbsp;<var class="var">x</var>*<var class="var">y</var>.&rsquo;<!-- /@w -->, where <var class="var">x</var> and <var class="var">y</var> are
column vectors (rank-1 update) or matrices with equal number of columns
(rank-k update).
</p>
<p>Optionally, row-pivoted updating can be used by supplying a row permutation
(pivoting) matrix <var class="var">P</var>; in that case, an updated permutation matrix is
returned.  Note that if <var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var> is a pivoted
LU&nbsp;factorization as obtained by <code class="code">lu</code>:
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>] = lu (<var class="var">A</var>);
</pre></div>

<p>then a factorization of <code class="code"><var class="var">A</var>+<var class="var">x</var>*<var class="var">y</var>.'</code> can be obtained
either as
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">L1</var>, <var class="var">U1</var>] = lu (<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>*<var class="var">x</var>, <var class="var">y</var>)
</pre></div>

<p>or
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">L1</var>, <var class="var">U1</var>, <var class="var">P1</var>] = lu (<var class="var">L</var>, <var class="var">U</var>, <var class="var">P</var>, <var class="var">x</var>, <var class="var">y</var>)
</pre></div>

<p>The first form uses the unpivoted algorithm, which is faster, but less
stable.  The second form uses a slower pivoted algorithm, which is more
stable.
</p>
<p>The matrix case is done as a sequence of rank-1 updates; thus, for large
enough k, it will be both faster and more accurate to recompute the
factorization from scratch.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFcholupdate">cholupdate</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>.
</p></dd></dl>


<a class="anchor" id="XREFqr"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qr"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Q</var>, <var class="var">R</var>] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-qr"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Q</var>, <var class="var">R</var>, <var class="var">P</var>] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-qr-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">X</var> =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)  # non-sparse A</code><a class="copiable-link" href="#index-qr-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">R</var> =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>)  # sparse A</code><a class="copiable-link" href="#index-qr-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">X</var> =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>) # sparse A</code><a class="copiable-link" href="#index-qr-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-5"><span class="category-def">: </span><span><code class="def-type">[<var class="var">C</var>, <var class="var">R</var>] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-qr-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-6"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(&hellip;, 0)</code><a class="copiable-link" href="#index-qr-6"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-7"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(&hellip;, &quot;econ&quot;)</code><a class="copiable-link" href="#index-qr-7"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-8"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(&hellip;, &quot;vector&quot;)</code><a class="copiable-link" href="#index-qr-8"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qr-9"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">qr</strong> <code class="def-code-arguments">(&hellip;, &quot;matrix&quot;)</code><a class="copiable-link" href="#index-qr-9"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-QR-factorization"></a>
<p>Compute the QR&nbsp;factorization of <var class="var">A</var>, using standard <small class="sc">LAPACK</small>
subroutines.
</p>
<p>The QR&nbsp;factorization is
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">Q</var> * <var class="var">R</var> = <var class="var">A</var>
</pre></div>

<p>where <var class="var">Q</var> is an orthogonal matrix and <var class="var">R</var> is upper triangular.
</p>
<p>For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>,
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">Q</var>, <var class="var">R</var>] = qr (<var class="var">A</var>)
</pre></div>

<p>returns
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"><var class="var">Q</var> =

  -0.31623  -0.94868
  -0.94868   0.31623

<var class="var">R</var> =

  -3.16228  -4.42719
   0.00000  -0.63246
</pre></div></div>

<p>which multiplied together return the original matrix
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"><var class="var">Q</var> * <var class="var">R</var>
  &rArr;
     1.0000   2.0000
     3.0000   4.0000
</pre></div></div>

<p>If just a single return value is requested then it is either <var class="var">R</var>, if
<var class="var">A</var> is sparse, or <var class="var">X</var>, such that <code class="code"><var class="var">R</var> = triu (<var class="var">X</var>)</code> if
<var class="var">A</var> is full.  (Note: unlike most commands, the single return value is not
the first return value when multiple values are requested.)
</p>
<p>If a third output <var class="var">P</var> is requested, then <code class="code">qr</code> calculates the permuted
QR&nbsp;factorization
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">Q</var> * <var class="var">R</var> = <var class="var">A</var> * <var class="var">P</var>
</pre></div>

<p>where <var class="var">Q</var> is an orthogonal matrix, <var class="var">R</var> is upper triangular, and
<var class="var">P</var> is a permutation matrix.
</p>
<p>If <var class="var">A</var> is dense, the permuted QR&nbsp;factorization has the additional
property that the diagonal entries of <var class="var">R</var> are ordered by decreasing
magnitude.  In other words, <code class="code">abs (diag (<var class="var">R</var>))</code> will be ordered
from largest to smallest.
</p>
<p>If <var class="var">A</var> is sparse, <var class="var">P</var> is a fill-reducing ordering of the columns
of <var class="var">A</var>.  In that case, the diagonal entries of <var class="var">R</var> are not ordered by
decreasing magnitude.
</p>
<p>For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>,
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">Q</var>, <var class="var">R</var>, <var class="var">P</var>] = qr (<var class="var">A</var>)
</pre></div>

<p>returns
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"><var class="var">Q</var> =

  -0.44721  -0.89443
  -0.89443   0.44721

<var class="var">R</var> =

  -4.47214  -3.13050
   0.00000   0.44721

<var class="var">P</var> =

   0  1
   1  0
</pre></div></div>

<p>If the input matrix <var class="var">A</var> is sparse, the sparse QR&nbsp;factorization
is computed by using <small class="sc">SPQR</small> or <small class="sc">CXSPARSE</small> (e.g., if <small class="sc">SPQR</small> is not
available).  Because the matrix <var class="var">Q</var> is, in general, a full matrix, it is
recommended to request only one return value <var class="var">R</var>.  In that case, the
computation avoids the construction of <var class="var">Q</var> and returns a sparse <var class="var">R</var>
such that <code class="code"><var class="var">R</var> = chol (<var class="var">A</var>' * <var class="var">A</var>)</code>.
</p>
<p>If <var class="var">A</var> is dense, an additional matrix <var class="var">B</var> is supplied and two
return values are requested, then <code class="code">qr</code> returns <var class="var">C</var>, where
<code class="code"><var class="var">C</var> = <var class="var">Q</var>' * <var class="var">B</var></code>.  This allows the least squares
approximation of <code class="code"><var class="var">A</var> \ <var class="var">B</var></code> to be calculated as
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[<var class="var">C</var>, <var class="var">R</var>] = qr (<var class="var">A</var>, <var class="var">B</var>)
<var class="var">X</var> = <var class="var">R</var> \ <var class="var">C</var>
</pre></div></div>

<p>If <var class="var">A</var> is a sparse MxN matrix and an additional matrix <var class="var">B</var> is
supplied, one or two return values are possible.  If one return value <var class="var">X</var>
is requested and M &lt; N, then <var class="var">X</var> is the minimum 2-norm solution of
<code class="code"><var class="var">A</var>&nbsp;\&nbsp;<var class="var">B</var></code><!-- /@w -->.  If M &gt;= N, <var class="var">X</var> is the least squares
approximation of&nbsp;<code class="code"><var class="var">A</var>&nbsp;\&nbsp;<var class="var">B</var></code><!-- /@w -->.  If two return values are
requested, <var class="var">C</var> and <var class="var">R</var> have the same meaning as in the dense case
(<var class="var">C</var> is dense and <var class="var">R</var> is sparse).  The version with one return
parameter should be preferred because it uses less memory and can handle
rank-deficient matrices better.
</p>
<p>If the final argument is the string <code class="code">&quot;vector&quot;</code> then <var class="var">P</var> is a
permutation vector (of the columns of <var class="var">A</var>) instead of a permutation
matrix.  In this case, the defining relationship is:
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">Q</var> * <var class="var">R</var> = <var class="var">A</var>(:, <var class="var">P</var>)
</pre></div>

<p>The default, however, is to return a permutation matrix and this may be
explicitly specified by using a final argument of <code class="code">&quot;matrix&quot;</code>.
</p>
<p>If the final argument is the scalar 0 or the string <code class="code">&quot;econ&quot;</code>, an economy
factorization is returned.  If the original matrix <var class="var">A</var> has size
MxN and M &gt; N, then the economy factorization will calculate just N
rows in <var class="var">R</var> and N columns in <var class="var">Q</var> and omit the zeros in <var class="var">R</var>.  If M
&le; N, there is no difference between the economy and standard
factorizations.  When calculating an economy factorization and <var class="var">A</var> is
dense, the output <var class="var">P</var> is always a vector rather than a matrix.  If <var class="var">A</var>
is sparse, output <var class="var">P</var> is a sparse permutation matrix.
</p>
<p>Background: The QR factorization has applications in the solution of least
squares problems
</p>
<div class="example">
<pre class="example-preformatted">min norm (A*x - b)
</pre></div>

<p>for overdetermined systems of equations (i.e.,
<var class="var">A</var>
is a tall, thin matrix).
</p>
<p>The permuted QR&nbsp;factorization
<code class="code">[<var class="var">Q</var>, <var class="var">R</var>, <var class="var">P</var>] = qr (<var class="var">A</var>)</code> allows the construction of an
orthogonal basis of <code class="code">span (A)</code>.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>, <a class="ref" href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFqrupdate"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qrupdate"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrupdate</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">u</var>, <var class="var">v</var>)</code><a class="copiable-link" href="#index-qrupdate"> &para;</a></span></dt>
<dd><p>Update a QR factorization given update vectors or matrices.
</p>
<p>Given a QR&nbsp;factorization of a real or complex matrix
<var class="var">A</var>&nbsp;=&nbsp;<var class="var">Q</var>*<var class="var">R</var><!-- /@w -->, <var class="var">Q</var>&nbsp;unitary and
<var class="var">R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
<var class="var">A</var>&nbsp;+&nbsp;<var class="var">u</var>*<var class="var">v</var>&rsquo;<!-- /@w -->, where <var class="var">u</var> and <var class="var">v</var> are column vectors
(rank-1 update) or matrices with equal number of columns
(rank-k update).  Notice that the latter case is done as a sequence of
rank-1 updates; thus, for k large enough, it will be both faster and more
accurate to recompute the factorization from scratch.
</p>
<p>The QR&nbsp;factorization supplied may be either full (Q is square) or
economized (R is square).
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>, <a class="ref" href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFqrinsert"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qrinsert"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrinsert</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">j</var>, <var class="var">x</var>, <var class="var">orient</var>)</code><a class="copiable-link" href="#index-qrinsert"> &para;</a></span></dt>
<dd><p>Update a QR factorization given a row or column to insert in the original
factored matrix.
</p>

<p>Given a QR&nbsp;factorization of a real or complex matrix
<var class="var">A</var>&nbsp;=&nbsp;<var class="var">Q</var>*<var class="var">R</var><!-- /@w -->, <var class="var">Q</var>&nbsp;unitary and
<var class="var">R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
[A(:,1:j-1)&nbsp;x&nbsp;A(:,j:n)]<!-- /@w -->, where <var class="var">u</var> is a column vector to be inserted
into <var class="var">A</var> (if <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>), or the
QR&nbsp;factorization of [A(1:j-1,:);x;A(:,j:n)]<!-- /@w -->, where <var class="var">x</var> is a row
vector to be inserted into <var class="var">A</var> (if <var class="var">orient</var> is <code class="code">&quot;row&quot;</code>).
</p>
<p>The default value of <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>.  If <var class="var">orient</var> is
<code class="code">&quot;col&quot;</code>, <var class="var">u</var> may be a matrix and <var class="var">j</var> an index vector
resulting in the QR&nbsp;factorization of a matrix <var class="var">B</var> such that
B(:,<var class="var">j</var>)<!-- /@w --> gives <var class="var">u</var> and B(:,<var class="var">j</var>)&nbsp;=&nbsp;[]<!-- /@w --> gives <var class="var">A</var>.
Notice that the latter case is done as a sequence of k insertions;
thus, for k large enough, it will be both faster and more accurate to
recompute the factorization from scratch.
</p>
<p>If <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>, the QR&nbsp;factorization supplied may
be either full (Q is square) or economized (R is square).
</p>
<p>If <var class="var">orient</var> is <code class="code">&quot;row&quot;</code>, full factorization is needed.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>, <a class="ref" href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFqrdelete"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qrdelete"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrdelete</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">j</var>, <var class="var">orient</var>)</code><a class="copiable-link" href="#index-qrdelete"> &para;</a></span></dt>
<dd><p>Update a QR factorization given a row or column to delete from the original
factored matrix.
</p>
<p>Given a QR&nbsp;factorization of a real or complex matrix
<var class="var">A</var>&nbsp;=&nbsp;<var class="var">Q</var>*<var class="var">R</var><!-- /@w -->, <var class="var">Q</var>&nbsp;unitary and
<var class="var">R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization of
[A(:,1:j-1),&nbsp;U,&nbsp;A(:,j:n)]<!-- /@w -->,
where <var class="var">u</var> is a column vector to be inserted into <var class="var">A</var>
(if <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>),
or the QR&nbsp;factorization of [A(1:j-1,:);X;A(:,j:n)]<!-- /@w -->,
where <var class="var">x</var> is a row <var class="var">orient</var> is <code class="code">&quot;row&quot;</code>).
The default value of <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>.
</p>
<p>If <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>, <var class="var">j</var> may be an index vector
resulting in the QR&nbsp;factorization of a matrix <var class="var">B</var> such that
A(:,<var class="var">j</var>)&nbsp;=&nbsp;[]<!-- /@w --> gives <var class="var">B</var>.  Notice that the latter case is done as
a sequence of k deletions; thus, for k large enough, it will be both faster
and more accurate to recompute the factorization from scratch.
</p>
<p>If <var class="var">orient</var> is <code class="code">&quot;col&quot;</code>, the QR&nbsp;factorization supplied may
be either full (Q is square) or economized (R is square).
</p>
<p>If <var class="var">orient</var> is <code class="code">&quot;row&quot;</code>, full factorization is needed.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrshift">qrshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFqrshift"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qrshift"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Q1</var>, <var class="var">R1</var>] =</code> <strong class="def-name">qrshift</strong> <code class="def-code-arguments">(<var class="var">Q</var>, <var class="var">R</var>, <var class="var">i</var>, <var class="var">j</var>)</code><a class="copiable-link" href="#index-qrshift"> &para;</a></span></dt>
<dd><p>Update a QR factorization given a range of columns to shift in the original
factored matrix.
</p>
<p>Given a QR&nbsp;factorization of a real or complex matrix
<var class="var">A</var>&nbsp;=&nbsp;<var class="var">Q</var>*<var class="var">R</var><!-- /@w -->, <var class="var">Q</var>&nbsp;unitary and
<var class="var">R</var>&nbsp;upper trapezoidal, return the QR&nbsp;factorization
of <var class="var">A</var>(:,p)<!-- /@w -->, where p<!-- /@w --> is the permutation <br>
<code class="code">p = [1:i-1, shift(i:j, 1), j+1:n]</code> if <var class="var">i</var>&nbsp;&lt;&nbsp;<var class="var">j</var><!-- /@w --> <br>
 or <br>
<code class="code">p = [1:j-1, shift(j:i,-1), i+1:n]</code> if <var class="var">j</var>&nbsp;&lt;&nbsp;<var class="var">i</var><!-- /@w -->.  <br>
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqrupdate">qrupdate</a>, <a class="ref" href="#XREFqrinsert">qrinsert</a>, <a class="ref" href="#XREFqrdelete">qrdelete</a>.
</p></dd></dl>


<a class="anchor" id="XREFqz"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qz"><span class="category-def">: </span><span><code class="def-type">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">V</var>, <var class="var">W</var>] =</code> <strong class="def-name">qz</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-qz"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-qz-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">V</var>, <var class="var">W</var>] =</code> <strong class="def-name">qz</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-qz-1"> &para;</a></span></dt>
<dd><p>Compute the QZ&nbsp;decomposition of a generalized eigenvalue problem.
</p>
<p>The generalized eigenvalue problem is defined as
</p>

<p><em class="math">A x = <var class="var">lambda</var> B x</em>
</p>

<p>There are two calling forms of the function:
</p>
<ol class="enumerate">
<li> <code class="code">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">V</var>, <var class="var">W</var>, <var class="var">lambda</var>] = qz (<var class="var">A</var>, <var class="var">B</var>)</code>

<p>Compute the complex QZ&nbsp;decomposition, generalized eigenvectors, and
generalized eigenvalues.
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">

<var class="var">AA</var> = <var class="var">Q</var> * <var class="var">A</var> * <var class="var">Z</var>, <var class="var">BB</var> = <var class="var">Q</var> * <var class="var">B</var> * <var class="var">Z</var>
<var class="var">A</var> * <var class="var">V</var> * diag (diag (<var class="var">BB</var>)) = <var class="var">B</var> * <var class="var">V</var> * diag (diag (<var class="var">AA</var>))
diag (diag (<var class="var">BB</var>)) * <var class="var">W</var>' * <var class="var">A</var> = diag (diag (<var class="var">AA</var>)) * <var class="var">W</var>' * <var class="var">B</var>

</pre></div></div>

<p>with <var class="var">AA</var> and <var class="var">BB</var> upper triangular, and <var class="var">Q</var> and <var class="var">Z</var>
unitary.  The matrices <var class="var">V</var> and <var class="var">W</var> respectively contain the right
and left generalized eigenvectors.
</p>
</li><li> <code class="code">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Z</var> {, <var class="var">lambda</var>}] = qz (<var class="var">A</var>, <var class="var">B</var>, <var class="var">opt</var>)</code>

<p>The <var class="var">opt</var> argument must be equal to either <code class="code">&quot;real&quot;</code> or
<code class="code">&quot;complex&quot;</code>.  If it is equal to <code class="code">&quot;complex&quot;</code>, then this
calling form is equivalent to the first one with only two input
arguments.
</p>
<p>If <var class="var">opt</var> is equal to <code class="code">&quot;real&quot;</code>, then the real QZ decomposition
is computed.  In particular, <var class="var">AA</var> is only guaranteed to be
quasi-upper triangular with 1-by-1 and 2-by-2 blocks on the diagonal,
and <var class="var">Q</var> and <var class="var">Z</var> are orthogonal.  The identities mentioned above
for right and left generalized eigenvectors are only verified if
<var class="var">AA</var> is upper triangular (i.e., when all the generalized eigenvalues
are real, in which case the real and complex QZ coincide).
</p>
</li></ol>

<p>Note: <code class="code">qz</code> performs permutation balancing, but not scaling
(see <a class="pxref" href="Basic-Matrix-Functions.html#XREFbalance"><code class="code">balance</code></a>), which may be lead to less accurate
results than <code class="code">eig</code>.  The order of output arguments was selected for
compatibility with <small class="sc">MATLAB</small>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFgsvd">gsvd</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFbalance">balance</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqzhess">qzhess</a>, <a class="ref" href="#XREFschur">schur</a>.
</p></dd></dl>


<a class="anchor" id="XREFqzhess"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-qzhess"><span class="category-def">: </span><span><code class="def-type">[<var class="var">aa</var>, <var class="var">bb</var>, <var class="var">q</var>, <var class="var">z</var>] =</code> <strong class="def-name">qzhess</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-qzhess"> &para;</a></span></dt>
<dd><p>Compute the Hessenberg-triangular decomposition of the matrix pencil
<code class="code">(<var class="var">A</var>, <var class="var">B</var>)</code>, returning
<code class="code"><var class="var">aa</var> = <var class="var">q</var> * <var class="var">A</var> * <var class="var">z</var></code>,
<code class="code"><var class="var">bb</var> = <var class="var">q</var> * <var class="var">B</var> * <var class="var">z</var></code>, with <var class="var">q</var> and <var class="var">z</var>
orthogonal.
</p>
<p>For example:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[aa, bb, q, z] = qzhess ([1, 2; 3, 4], [5, 6; 7, 8])
  &rArr; aa =
      -3.02244  -4.41741
       0.92998   0.69749
  &rArr; bb =
      -8.60233  -9.99730
       0.00000  -0.23250
  &rArr; q =
      -0.58124  -0.81373
      -0.81373   0.58124
  &rArr; z =
     Diagonal Matrix
       1   0
       0   1
</pre></div></div>

<p>The Hessenberg-triangular decomposition is the first step in
Moler and Stewart&rsquo;s QZ&nbsp;decomposition algorithm.
</p>
<p>Algorithm taken from Golub and Van Loan,
<cite class="cite">Matrix Computations, 2nd edition</cite>.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFsvd">svd</a>.
</p></dd></dl>


<a class="anchor" id="XREFschur"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-schur"><span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-schur"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-schur-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>, &quot;real&quot;)</code><a class="copiable-link" href="#index-schur-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-schur-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>, &quot;complex&quot;)</code><a class="copiable-link" href="#index-schur-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-schur-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">S</var> =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">opt</var>)</code><a class="copiable-link" href="#index-schur-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-schur-4"><span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>] =</code> <strong class="def-name">schur</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-schur-4"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-Schur-decomposition"></a>
<p>Compute the Schur&nbsp;decomposition of <var class="var">A</var>.
</p>
<p>The Schur&nbsp;decomposition of a square matrix <var class="var">A</var> is defined as
</p>
<div class="example">
<pre class="example-preformatted"><code class="code"><var class="var">S</var> = <var class="var">U</var>' * <var class="var">A</var> * <var class="var">U</var></code>
</pre></div>

<p>where <var class="var">U</var> is a unitary matrix
(<code class="code"><var class="var">U</var>'* <var class="var">U</var></code> is identity)
and <var class="var">S</var> is upper triangular.  The eigenvalues of <var class="var">A</var> (and <var class="var">S</var>)
are the diagonal elements of <var class="var">S</var>.  If the matrix <var class="var">A</var> is real, then
the real Schur&nbsp;decomposition is computed, in which the matrix <var class="var">U</var>
is orthogonal and <var class="var">S</var> is block upper triangular with blocks of size at
most
<code class="code">2 x 2</code>
along the diagonal.
</p>
<p>The default for real matrices is a real Schur&nbsp;decomposition.  A complex
decomposition may be forced by passing the flag <code class="code">&quot;complex&quot;</code>.
</p>
<p>The eigenvalues are optionally ordered along the diagonal according to the
value of <var class="var">opt</var>:
</p>
<dl class="table">
<dt><code class="code"><var class="var">opt</var> = &quot;a&quot;</code></dt>
<dd><p>Move eigenvalues with negative real parts to the leading block of <var class="var">S</var>.
Mnemonic: <code class="code">&quot;a&quot;</code> for Algebraic Riccati Equations, where this
ordering is useful.
</p>
</dd>
<dt><code class="code"><var class="var">opt</var> = &quot;d&quot;</code></dt>
<dd><p>Move eigenvalues with magnitude less than one to the leading block of <var class="var">S</var>.
Mnemonic: <code class="code">&quot;d&quot;</code> for Discrete Algebraic Riccati Equations,
where this ordering is useful.
</p>
</dd>
<dt><code class="code"><var class="var">opt</var> = &quot;u&quot;</code></dt>
<dd><p>Unordered.  No particular ordering of eigenvalues (default).
</p></dd>
</dl>

<p>The leading <var class="var">k</var> columns of <var class="var">U</var> always span the <var class="var">A</var>-invariant
subspace corresponding to the <var class="var">k</var> leading eigenvalues of <var class="var">S</var>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFrsf2csf">rsf2csf</a>, <a class="ref" href="#XREFordschur">ordschur</a>, <a class="ref" href="#XREFordeig">ordeig</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFsvd">svd</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>.
</p></dd></dl>


<a class="anchor" id="XREFrsf2csf"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-rsf2csf"><span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">T</var>] =</code> <strong class="def-name">rsf2csf</strong> <code class="def-code-arguments">(<var class="var">UR</var>, <var class="var">TR</var>)</code><a class="copiable-link" href="#index-rsf2csf"> &para;</a></span></dt>
<dd><p>Convert a real, upper quasi-triangular Schur&nbsp;form <var class="var">TR</var> to a
complex, upper triangular Schur&nbsp;form <var class="var">T</var>.
</p>
<p>Note that the following relations hold:
</p>
<p><code class="code"><var class="var">UR</var> * <var class="var">TR</var> * <var class="var">UR</var>' = <var class="var">U</var> * <var class="var">T</var> * <var class="var">U</var>'</code> and
<code class="code"><var class="var">U</var>' * <var class="var">U</var></code> is the identity matrix I.
</p>
<p>Note also that <var class="var">U</var> and <var class="var">T</var> are not unique.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFschur">schur</a>.
</p></dd></dl>


<a class="anchor" id="XREFordschur"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ordschur"><span class="category-def">: </span><span><code class="def-type">[<var class="var">UR</var>, <var class="var">SR</var>] =</code> <strong class="def-name">ordschur</strong> <code class="def-code-arguments">(<var class="var">U</var>, <var class="var">S</var>, <var class="var">select</var>)</code><a class="copiable-link" href="#index-ordschur"> &para;</a></span></dt>
<dd><p>Reorder the real Schur factorization (<var class="var">U</var>,<var class="var">S</var>) obtained with the
<code class="code">schur</code> function, so that selected eigenvalues appear in the upper left
diagonal blocks of the quasi triangular Schur matrix.
</p>
<p>The logical vector <var class="var">select</var> specifies the selected eigenvalues as they
appear along <var class="var">S</var>&rsquo;s diagonal.
</p>
<p>For example, given the matrix <code class="code"><var class="var">A</var> = [1, 2; 3, 4]</code>, and its Schur
decomposition
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">U</var>, <var class="var">S</var>] = schur (<var class="var">A</var>)
</pre></div>

<p>which returns
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"><var class="var">U</var> =

  -0.82456  -0.56577
   0.56577  -0.82456

<var class="var">S</var> =

  -0.37228  -1.00000
   0.00000   5.37228

</pre></div></div>

<p>It is possible to reorder the decomposition so that the positive eigenvalue
is in the upper left corner, by doing:
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">U</var>, <var class="var">S</var>] = ordschur (<var class="var">U</var>, <var class="var">S</var>, [0,1])
</pre></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFordeig">ordeig</a>, <a class="ref" href="#XREFordqz">ordqz</a>.
</p></dd></dl>


<a class="anchor" id="XREFordqz"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ordqz"><span class="category-def">: </span><span><code class="def-type">[<var class="var">AR</var>, <var class="var">BR</var>, <var class="var">QR</var>, <var class="var">ZR</var>] =</code> <strong class="def-name">ordqz</strong> <code class="def-code-arguments">(<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">keyword</var>)</code><a class="copiable-link" href="#index-ordqz"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ordqz-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">AR</var>, <var class="var">BR</var>, <var class="var">QR</var>, <var class="var">ZR</var>] =</code> <strong class="def-name">ordqz</strong> <code class="def-code-arguments">(<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>, <var class="var">select</var>)</code><a class="copiable-link" href="#index-ordqz-1"> &para;</a></span></dt>
<dd><p>Reorder the QZ&nbsp;decomposition of a generalized eigenvalue problem.
</p>
<p>The generalized eigenvalue problem is defined as
</p>

<p><em class="math">A x = <var class="var">lambda</var> B x</em>
</p>

<p>Its generalized Schur decomposition is computed using the <code class="code">qz</code> algorithm:
</p>
<p><code class="code">[<var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, <var class="var">Z</var>] = qz (<var class="var">A</var>, <var class="var">B</var>)</code>
</p>
<p>where <var class="var">AA</var>, <var class="var">BB</var>, <var class="var">Q</var>, and <var class="var">Z</var> fulfill
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">

<var class="var">AA</var> = <var class="var">Q</var> * <var class="var">A</var> * <var class="var">Z</var>, <var class="var">BB</var> = <var class="var">Q</var> * <var class="var">B</var> * <var class="var">Z</var>

</pre></div></div>


<p>The <code class="code">ordqz</code> function computes a unitary transformation <var class="var">QR</var> and
<var class="var">ZR</var> such that the order of the eigenvalue on the diagonal of <var class="var">AA</var> and
<var class="var">BB</var> is changed.  The resulting reordered matrices <var class="var">AR</var> and <var class="var">BR</var>
fulfill:
</p>

<div class="example">
<div class="group"><pre class="example-preformatted">

<var class="var">AR</var> = <var class="var">QR</var> * <var class="var">A</var> * <var class="var">ZR</var>, <var class="var">BR</var> = <var class="var">QR</var> * <var class="var">B</var> * <var class="var">ZR</var>

</pre></div></div>


<p>The function can either be called with the <var class="var">keyword</var> argument which
selects the eigenvalues in the top left block of <var class="var">AR</var> and <var class="var">BR</var> in the
following way:
</p>
<dl class="table">
<dt><code class="code">&quot;S&quot;</code>, <code class="code">&quot;udi&quot;</code></dt>
<dd><p>small: leading block has all
|<var class="var">lambda</var>| &lt; 1
</p>
</dd>
<dt><code class="code">&quot;B&quot;</code>, <code class="code">&quot;udo&quot;</code></dt>
<dd><p>big: leading block has all
|<var class="var">lambda</var>| &ge; 1
</p>
</dd>
<dt><code class="code">&quot;-&quot;</code>, <code class="code">&quot;lhp&quot;</code></dt>
<dd><p>negative real part: leading block has all eigenvalues in the open left
half-plane
</p>
</dd>
<dt><code class="code">&quot;+&quot;</code>, <code class="code">&quot;rhp&quot;</code></dt>
<dd><p>non-negative real part: leading block has all eigenvalues in the closed right
half-plane
</p></dd>
</dl>

<p>If a logical vector <var class="var">select</var> is given instead of a keyword the <code class="code">ordqz</code>
function reorders all eigenvalues <code class="code">k</code> to the left block for which
<code class="code">select(k)</code> is true.
</p>
<p>Note: The keywords are compatible with the ones from <code class="code">qr</code>.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFordeig">ordeig</a>, <a class="ref" href="#XREFqz">qz</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFordschur">ordschur</a>.
</p></dd></dl>


<a class="anchor" id="XREFordeig"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ordeig"><span class="category-def">: </span><span><code class="def-type"><var class="var">lambda</var> =</code> <strong class="def-name">ordeig</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-ordeig"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ordeig-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">lambda</var> =</code> <strong class="def-name">ordeig</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-ordeig-1"> &para;</a></span></dt>
<dd><p>Return the eigenvalues of quasi-triangular matrices in their order of
appearance in the matrix <var class="var">A</var>.
</p>
<p>The quasi-triangular matrix <var class="var">A</var> is usually the result of a Schur
factorization.  If called with a second input <var class="var">B</var> then the generalized
eigenvalues of the pair <var class="var">A</var>, <var class="var">B</var> are returned in the order of
appearance of the matrix <code class="code"><var class="var">A</var>-<var class="var">lambda</var>*<var class="var">B</var></code>.  The pair
<var class="var">A</var>, <var class="var">B</var> is usually the result of a QZ decomposition.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFordschur">ordschur</a>, <a class="ref" href="#XREFordqz">ordqz</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFschur">schur</a>, <a class="ref" href="#XREFqz">qz</a>.
</p></dd></dl>


<a class="anchor" id="XREFsubspace"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-subspace"><span class="category-def">: </span><span><code class="def-type"><var class="var">angle</var> =</code> <strong class="def-name">subspace</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-subspace"> &para;</a></span></dt>
<dd><p>Determine the largest principal angle between two subspaces
spanned by the columns of matrices <var class="var">A</var> and <var class="var">B</var>.
</p></dd></dl>


<a class="anchor" id="XREFsvd"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-svd"><span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-svd"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svd-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>, <var class="var">V</var>] =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-svd-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svd-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>, <var class="var">V</var>] =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>, &quot;econ&quot;)</code><a class="copiable-link" href="#index-svd-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svd-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">U</var>, <var class="var">S</var>, <var class="var">V</var>] =</code> <strong class="def-name">svd</strong> <code class="def-code-arguments">(<var class="var">A</var>, 0)</code><a class="copiable-link" href="#index-svd-3"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-singular-value-decomposition"></a>
<p>Compute the singular value decomposition of <var class="var">A</var>.
</p>
<p>The singular value decomposition is defined by the relation
</p>

<div class="example">
<pre class="example-preformatted">A = U*S*V'
</pre></div>


<p>The function <code class="code">svd</code> normally returns only the vector of singular values.
When called with three return values, it computes
<var class="var">U</var>, <var class="var">S</var>, and <var class="var">V</var>.
For example,
</p>
<div class="example">
<pre class="example-preformatted">svd (hilb (3))
</pre></div>

<p>returns
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">ans =

  1.4083189
  0.1223271
  0.0026873
</pre></div></div>

<p>and
</p>
<div class="example">
<pre class="example-preformatted">[u, s, v] = svd (hilb (3))
</pre></div>

<p>returns
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">u =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867

s =

  1.40832  0.00000  0.00000
  0.00000  0.12233  0.00000
  0.00000  0.00000  0.00269

v =

  -0.82704   0.54745   0.12766
  -0.45986  -0.52829  -0.71375
  -0.32330  -0.64901   0.68867
</pre></div></div>

<p>When given a second argument that is not 0, <code class="code">svd</code> returns an economy-sized
decomposition, eliminating the unnecessary rows or columns of <var class="var">U</var> or
<var class="var">V</var>.
</p>
<p>If the second argument is exactly 0, then the choice of decomposition is based
on the matrix <var class="var">A</var>.  If <var class="var">A</var> has more rows than columns then an
economy-sized decomposition is returned, otherwise a regular decomposition
is calculated.
</p>
<p>Algorithm Notes: When calculating the full decomposition (left and right
singular matrices in addition to singular values) there is a choice of two
routines in <small class="sc">LAPACK</small>.  The default routine used by Octave is <code class="code">gesvd</code>.
The alternative is <code class="code">gesdd</code> which is 5X faster, but may use more memory
and may be inaccurate for some input matrices.  There is a third routine
<code class="code">gejsv</code>, suitable for better accuracy at extreme scale.  See the
documentation for <code class="code">svd_driver</code> for more information on choosing a driver.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsvd_005fdriver">svd_driver</a>, <a class="ref" href="Sparse-Linear-Algebra.html#XREFsvds">svds</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFlu">lu</a>, <a class="ref" href="#XREFchol">chol</a>, <a class="ref" href="#XREFhess">hess</a>, <a class="ref" href="#XREFqr">qr</a>, <a class="ref" href="#XREFqz">qz</a>.
</p></dd></dl>


<a class="anchor" id="XREFsvd_005fdriver"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-svd_005fdriver"><span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">svd_driver</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-svd_005fdriver"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svd_005fdriver-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">old_val</var> =</code> <strong class="def-name">svd_driver</strong> <code class="def-code-arguments">(<var class="var">new_val</var>)</code><a class="copiable-link" href="#index-svd_005fdriver-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svd_005fdriver-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">old_val</var> =</code> <strong class="def-name">svd_driver</strong> <code class="def-code-arguments">(<var class="var">new_val</var>, &quot;local&quot;)</code><a class="copiable-link" href="#index-svd_005fdriver-2"> &para;</a></span></dt>
<dd><p>Query or set the underlying <small class="sc">LAPACK</small> driver used by <code class="code">svd</code>.
</p>
<p>Currently recognized values are <code class="code">&quot;gesdd&quot;</code>, <code class="code">&quot;gesvd&quot;</code>, and
<code class="code">&quot;gejsv&quot;</code>.  The default is <code class="code">&quot;gesvd&quot;</code>.
</p>
<p>When called from inside a function with the <code class="code">&quot;local&quot;</code> option, the
variable is changed locally for the function and any subroutines it calls.
The original variable value is restored when exiting the function.
</p>
<p>Algorithm Notes: The <small class="sc">LAPACK</small> library routines <code class="code">gesvd</code> and <code class="code">gesdd</code>
are different only when calculating the full singular value decomposition (left
and right singular matrices as well as singular values).  When calculating just
the singular values the following discussion is not relevant.
</p>
<p>The newer <code class="code">gesdd</code> routine is based on a Divide-and-Conquer algorithm that
is 5X faster than the alternative <code class="code">gesvd</code>, which is based on QR
factorization.  However, the new algorithm can use significantly more memory.
For an MxN input matrix the memory usage is of order O(min(M,N) ^ 2),
whereas the alternative is of order O(max(M,N)).
</p>
<p>The routine <code class="code">gejsv</code> uses a preconditioned Jacobi SVD algorithm.  Unlike
<code class="code">gesvd</code> and <code class="code">gesdd</code>, in <code class="code">gejsv</code>, there is no bidiagonalization
step that could contaminate accuracy in some extreme cases.  Also, <code class="code">gejsv</code>
is known to be optimally accurate in some sense.  However, the speed is slower
(single threaded at its core) and uses more memory (O(min(M,N) ^ 2 + M + N)).
</p>
<p>Beyond speed and memory issues, there have been instances where some input
matrices were not accurately decomposed by <code class="code">gesdd</code>.  See currently active
bug <a class="url" href="https://savannah.gnu.org/bugs/?55564">https://savannah.gnu.org/bugs/?55564</a>.  Until these accuracy issues
are resolved in a new version of the <small class="sc">LAPACK</small> library, the default driver
in Octave has been set to <code class="code">&quot;gesvd&quot;</code>.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsvd">svd</a>.
</p></dd></dl>



<a class="anchor" id="XREFhoush"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-housh"><span class="category-def">: </span><span><code class="def-type">[<var class="var">housv</var>, <var class="var">beta</var>, <var class="var">zer</var>] =</code> <strong class="def-name">housh</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">j</var>, <var class="var">z</var>)</code><a class="copiable-link" href="#index-housh"> &para;</a></span></dt>
<dd><p>Compute Householder reflection vector <var class="var">housv</var> to reflect <var class="var">x</var> to be
the j-th column of identity, i.e.,
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">(I - beta*housv*housv')x =  norm (x)*e(j) if x(j) &lt; 0,
(I - beta*housv*housv')x = -norm (x)*e(j) if x(j) &gt;= 0
</pre></div></div>

<p>Inputs
</p>
<dl class="table">
<dt><var class="var">x</var></dt>
<dd><p>vector
</p>
</dd>
<dt><var class="var">j</var></dt>
<dd><p>index into vector
</p>
</dd>
<dt><var class="var">z</var></dt>
<dd><p>threshold for zero  (usually should be the number 0)
</p></dd>
</dl>

<p>Outputs (see Golub and Van Loan):
</p>
<dl class="table">
<dt><var class="var">beta</var></dt>
<dd><p>If beta = 0, then no reflection need be applied (zer set to 0)
</p>
</dd>
<dt><var class="var">housv</var></dt>
<dd><p>householder vector
</p></dd>
</dl>
</dd></dl>


<a class="anchor" id="XREFkrylov"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-krylov"><span class="category-def">: </span><span><code class="def-type">[<var class="var">u</var>, <var class="var">h</var>, <var class="var">nu</var>] =</code> <strong class="def-name">krylov</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">V</var>, <var class="var">k</var>, <var class="var">eps1</var>, <var class="var">pflg</var>)</code><a class="copiable-link" href="#index-krylov"> &para;</a></span></dt>
<dd><p>Construct an orthogonal basis <var class="var">u</var> of a block Krylov subspace.
</p>
<p>The block Krylov subspace has the following form:
</p>
<div class="example">
<pre class="example-preformatted">[v a*v a^2*v ... a^(k+1)*v]
</pre></div>

<p>The construction is made with Householder reflections to guard against loss
of orthogonality.
</p>
<p>If <var class="var">V</var> is a vector, then <var class="var">h</var> contains the Hessenberg matrix
such that <code class="code">a*u == u*h+rk*ek'</code>, in which
<code class="code">rk = a*u(:,k)-u*h(:,k)</code>, and <code class="code">ek'</code> is the vector
<code class="code">[0, 0, &hellip;, 1]</code> of length <var class="var">k</var>.  Otherwise, <var class="var">h</var> is
meaningless.
</p>
<p>If <var class="var">V</var> is a vector and <var class="var">k</var> is greater than <code class="code">length (A) - 1</code>,
then <var class="var">h</var> contains the Hessenberg matrix such that <code class="code">a*u == u*h</code>.
</p>
<p>The value of <var class="var">nu</var> is the dimension of the span of the Krylov subspace
(based on <var class="var">eps1</var>).
</p>
<p>If <var class="var">b</var> is a vector and <var class="var">k</var> is greater than <var class="var">m-1</var>, then <var class="var">h</var>
contains the Hessenberg decomposition of <var class="var">A</var>.
</p>
<p>The optional parameter <var class="var">eps1</var> is the threshold for zero.  The default
value is 1e-12.
</p>
<p>If the optional parameter <var class="var">pflg</var> is nonzero, row pivoting is used to
improve numerical behavior.  The default value is 0.
</p>
<p>Reference: A. Hodel, P. Misra, <cite class="cite">Partial Pivoting in the
Computation of Krylov Subspaces of Large Sparse Systems</cite>, Proceedings of
the 42nd IEEE Conference on Decision and Control, December 2003.
</p></dd></dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Functions-of-a-Matrix.html">Functions of a Matrix</a>, Previous: <a href="Basic-Matrix-Functions.html">Basic Matrix Functions</a>, Up: <a href="Linear-Algebra.html">Linear Algebra</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
