<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Signal Processing (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Signal Processing (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Signal Processing (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Image-Processing.html" rel="next" title="Image Processing">
<link href="Geometry.html" rel="prev" title="Geometry">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="chapter-level-extent" id="Signal-Processing">
<div class="nav-panel">
<p>
Next: <a href="Image-Processing.html" accesskey="n" rel="next">Image Processing</a>, Previous: <a href="Geometry.html" accesskey="p" rel="prev">Geometry</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h2 class="chapter" id="Signal-Processing-1"><span>31 Signal Processing<a class="copiable-link" href="#Signal-Processing-1"> &para;</a></span></h2>

<p>This chapter describes the signal processing and fast Fourier
transform functions available in Octave.  Fast Fourier transforms are
computed with the <small class="sc">FFTW</small> or <small class="sc">FFTPACK</small> libraries depending on how
Octave is built.
</p>
<a class="anchor" id="XREFfft"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fft"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fft</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-fft"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fft-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fft-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fft-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-fft-2"> &para;</a></span></dt>
<dd><p>Compute the discrete Fourier transform of <var class="var">x</var> using
a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The FFT is calculated along the first non-singleton dimension of the
array.  Thus if <var class="var">x</var> is a matrix, <code class="code">fft (<var class="var">x</var>)</code> computes the
FFT for each column of <var class="var">x</var>.
</p>
<p>If called with two arguments, <var class="var">n</var> is expected to be an integer
specifying the number of elements of <var class="var">x</var> to use, or an empty
matrix to specify that its value should be ignored.  If <var class="var">n</var> is
larger than the dimension along which the FFT is calculated, then
<var class="var">x</var> is resized and padded with zeros.  Otherwise, if <var class="var">n</var> is
smaller than the dimension along which the FFT is calculated, then
<var class="var">x</var> is truncated.
</p>
<p>If called with three arguments, <var class="var">dim</var> is an integer specifying the
dimension of the matrix along which the FFT is performed.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFfftw">fftw</a>.
</p></dd></dl>


<a class="anchor" id="XREFifft"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ifft"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifft</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-ifft"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ifft-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifft</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-ifft-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ifft-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifft</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-ifft-2"> &para;</a></span></dt>
<dd><p>Compute the inverse discrete Fourier transform of <var class="var">y</var>
using a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The inverse FFT is calculated along the first non-singleton dimension
of the array.  Thus if <var class="var">y</var> is a matrix, <code class="code">ifft (<var class="var">y</var>)</code> computes
the inverse FFT for each column of <var class="var">y</var>.
</p>
<p>If called with two arguments, <var class="var">n</var> is expected to be an integer
specifying the number of elements of <var class="var">y</var> to use, or an empty
matrix to specify that its value should be ignored.  If <var class="var">n</var> is
larger than the dimension along which the inverse FFT is calculated, then
<var class="var">y</var> is resized and padded with zeros.  Otherwise, if <var class="var">n</var> is
smaller than the dimension along which the inverse FFT is calculated,
then <var class="var">y</var> is truncated.
</p>
<p>If called with three arguments, <var class="var">dim</var> is an integer specifying the
dimension of the matrix along which the inverse FFT is performed.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFifftn">ifftn</a>, <a class="ref" href="#XREFfftw">fftw</a>.
</p></dd></dl>


<a class="anchor" id="XREFfft2"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fft2"><span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fft2</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-fft2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fft2-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fft2</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fft2-1"> &para;</a></span></dt>
<dd><p>Compute the two-dimensional discrete Fourier transform of <var class="var">A</var> using
a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional arguments <var class="var">m</var> and <var class="var">n</var> may be used specify the number of
rows and columns of <var class="var">A</var> to use.  If either of these is larger than the
size of <var class="var">A</var>, <var class="var">A</var> is resized and padded with zeros.
</p>
<p>If <var class="var">A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <var class="var">A</var> is treated separately.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFfftw">fftw</a>.
</p></dd></dl>


<a class="anchor" id="XREFifft2"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ifft2"><span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifft2</strong> <code class="def-code-arguments">(<var class="var">B</var>)</code><a class="copiable-link" href="#index-ifft2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ifft2-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifft2</strong> <code class="def-code-arguments">(<var class="var">B</var>, <var class="var">m</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-ifft2-1"> &para;</a></span></dt>
<dd><p>Compute the inverse two-dimensional discrete Fourier transform of <var class="var">B</var>
using a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional arguments <var class="var">m</var> and <var class="var">n</var> may be used specify the number of
rows and columns of <var class="var">B</var> to use.  If either of these is larger than the
size of <var class="var">B</var>, <var class="var">B</var> is resized and padded with zeros.
</p>
<p>If <var class="var">B</var> is a multi-dimensional matrix, each two-dimensional sub-matrix
of <var class="var">B</var> is treated separately.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFifftn">ifftn</a>, <a class="ref" href="#XREFfftw">fftw</a>.
</p></dd></dl>


<a class="anchor" id="XREFfftn"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fftn"><span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fftn</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-fftn"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftn-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">B</var> =</code> <strong class="def-name">fftn</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">size</var>)</code><a class="copiable-link" href="#index-fftn-1"> &para;</a></span></dt>
<dd><p>Compute the N-dimensional discrete Fourier transform of <var class="var">A</var> using
a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional vector argument <var class="var">size</var> may be used specify the dimensions
of the array to be used.  If an element of <var class="var">size</var> is smaller than the
corresponding dimension of <var class="var">A</var>, then the dimension of <var class="var">A</var> is
truncated prior to performing the FFT.  Otherwise, if an element of
<var class="var">size</var> is larger than the corresponding dimension then <var class="var">A</var> is
resized and padded with zeros.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifftn">ifftn</a>, <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFfftw">fftw</a>.
</p></dd></dl>


<a class="anchor" id="XREFifftn"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ifftn"><span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifftn</strong> <code class="def-code-arguments">(<var class="var">B</var>)</code><a class="copiable-link" href="#index-ifftn"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ifftn-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">A</var> =</code> <strong class="def-name">ifftn</strong> <code class="def-code-arguments">(<var class="var">B</var>, <var class="var">size</var>)</code><a class="copiable-link" href="#index-ifftn-1"> &para;</a></span></dt>
<dd><p>Compute the inverse N-dimensional discrete Fourier transform of <var class="var">B</var>
using a Fast Fourier Transform (FFT) algorithm.
</p>
<p>The optional vector argument <var class="var">size</var> may be used specify the dimensions
of the array to be used.  If an element of <var class="var">size</var> is smaller than the
corresponding dimension of <var class="var">B</var>, then the dimension of <var class="var">B</var> is
truncated prior to performing the inverse FFT.  Otherwise, if an element of
<var class="var">size</var> is larger than the corresponding dimension then <var class="var">B</var> is
resized and padded with zeros.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFfftw">fftw</a>.
</p></dd></dl>


<p>Octave uses the <small class="sc">FFTW</small> libraries to perform FFT computations.  When Octave
starts up and initializes the <small class="sc">FFTW</small> libraries, they read a system wide
file (on a Unix system, it is typically <samp class="file">/etc/fftw/wisdom</samp>) that
contains information useful to speed up FFT computations.  This
information is called the <em class="emph">wisdom</em>.  The system-wide file allows
wisdom to be shared between all applications using the <small class="sc">FFTW</small> libraries.
</p>
<p>Use the <code class="code">fftw</code> function to generate and save wisdom.  Using the
utilities provided together with the <small class="sc">FFTW</small> libraries
(<code class="command">fftw-wisdom</code> on Unix systems), you can even add wisdom
generated by Octave to the system-wide wisdom file.
</p>
<a class="anchor" id="XREFfftw"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fftw"><span class="category-def">: </span><span><code class="def-type"><var class="var">method</var> =</code> <strong class="def-name">fftw</strong> <code class="def-code-arguments">(&quot;planner&quot;)</code><a class="copiable-link" href="#index-fftw"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-1"><span class="category-def">: </span><span><strong class="def-name">fftw</strong> <code class="def-code-arguments">(&quot;planner&quot;, <var class="var">method</var>)</code><a class="copiable-link" href="#index-fftw-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">wisdom</var> =</code> <strong class="def-name">fftw</strong> <code class="def-code-arguments">(&quot;dwisdom&quot;)</code><a class="copiable-link" href="#index-fftw-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-3"><span class="category-def">: </span><span><strong class="def-name">fftw</strong> <code class="def-code-arguments">(&quot;dwisdom&quot;, <var class="var">wisdom</var>)</code><a class="copiable-link" href="#index-fftw-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">nthreads</var> =</code> <strong class="def-name">fftw</strong> <code class="def-code-arguments">(&quot;threads&quot;)</code><a class="copiable-link" href="#index-fftw-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftw-5"><span class="category-def">: </span><span><strong class="def-name">fftw</strong> <code class="def-code-arguments">(&quot;threads&quot;, <var class="var">nthreads</var>)</code><a class="copiable-link" href="#index-fftw-5"> &para;</a></span></dt>
<dd>
<p>Manage <small class="sc">FFTW</small> wisdom data.
</p>
<p>Wisdom data can be used to significantly accelerate the calculation of the
FFTs, but implies an initial cost in its calculation.  When the <small class="sc">FFTW</small>
libraries are initialized, they read a system wide wisdom file (typically in
<samp class="file">/etc/fftw/wisdom</samp>), allowing wisdom to be shared between applications
other than Octave.  Alternatively, the <code class="code">fftw</code> function can be used to
import wisdom.  For example,
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">wisdom</var> = fftw (&quot;dwisdom&quot;)
</pre></div>

<p>will save the existing wisdom used by Octave to the string <var class="var">wisdom</var>.
This string can then be saved to a file and restored using the <code class="code">save</code>
and <code class="code">load</code> commands respectively.  This existing wisdom can be
re-imported as follows
</p>
<div class="example">
<pre class="example-preformatted">fftw (&quot;dwisdom&quot;, <var class="var">wisdom</var>)
</pre></div>

<p>If <var class="var">wisdom</var> is an empty string, then the wisdom used is cleared.
</p>
<p>During the calculation of Fourier transforms further wisdom is generated.
The fashion in which this wisdom is generated is also controlled by
the <code class="code">fftw</code> function.  There are five different manners in which the
wisdom can be treated:
</p>
<dl class="table">
<dt><code class="code">&quot;estimate&quot;</code></dt>
<dd><p>Specifies that no run-time measurement of the optimal means of
calculating a particular is performed, and a simple heuristic is used
to pick a (probably sub-optimal) plan.  The advantage of this method is
that there is little or no overhead in the generation of the plan, which
is appropriate for a Fourier transform that will be calculated once.
</p>
</dd>
<dt><code class="code">&quot;measure&quot;</code></dt>
<dd><p>In this case a range of algorithms to perform the transform is considered
and the best is selected based on their execution time.
</p>
</dd>
<dt><code class="code">&quot;patient&quot;</code></dt>
<dd><p>Similar to <code class="code">&quot;measure&quot;</code>, but a wider range of algorithms is
considered.
</p>
</dd>
<dt><code class="code">&quot;exhaustive&quot;</code></dt>
<dd><p>Like <code class="code">&quot;measure&quot;</code>, but all possible algorithms that may be used to
treat the transform are considered.
</p>
</dd>
<dt><code class="code">&quot;hybrid&quot;</code></dt>
<dd><p>As run-time measurement of the algorithm can be expensive, this is a
compromise where <code class="code">&quot;measure&quot;</code> is used for transforms up to the size
of 8192 and beyond that the <code class="code">&quot;estimate&quot;</code> method is used.
</p></dd>
</dl>

<p>The default method is <code class="code">&quot;estimate&quot;</code>.  The current method can
be queried with
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">method</var> = fftw (&quot;planner&quot;)
</pre></div>

<p>or set by using
</p>
<div class="example">
<pre class="example-preformatted">fftw (&quot;planner&quot;, <var class="var">method</var>)
</pre></div>

<p>Note that calculated wisdom will be lost when restarting Octave.  However,
the wisdom data can be reloaded if it is saved to a file as described
above.  Saved wisdom files should not be used on different platforms since
they will not be efficient and the point of calculating the wisdom is lost.
</p>
<p>The number of threads used for computing the plans and executing the
transforms can be set with
</p>
<div class="example">
<pre class="example-preformatted">fftw (&quot;threads&quot;, <var class="var">NTHREADS</var>)
</pre></div>

<p>Note that Octave must be compiled with multi-threaded <small class="sc">FFTW</small> support for
this feature.  By default, the number of (logical) processors available to the
current process or <var class="var">3</var> is used (whichever is smaller).
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft">fft</a>, <a class="ref" href="#XREFifft">ifft</a>, <a class="ref" href="#XREFfft2">fft2</a>, <a class="ref" href="#XREFifft2">ifft2</a>, <a class="ref" href="#XREFfftn">fftn</a>, <a class="ref" href="#XREFifftn">ifftn</a>.
</p></dd></dl>


<a class="anchor" id="XREFfftconv"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fftconv"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">fftconv</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-fftconv"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftconv-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">fftconv</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fftconv-1"> &para;</a></span></dt>
<dd><p>Convolve two vectors using the FFT for computation.
</p>
<p><code class="code">c = fftconv (<var class="var">x</var>, <var class="var">y</var>)</code> returns a vector of length equal to
<code class="code">length (<var class="var">x</var>) + length (<var class="var">y</var>) - 1</code>.  If <var class="var">x</var> and <var class="var">y</var>
are the coefficient vectors of two polynomials, the returned value is the
coefficient vector of the product polynomial.
</p>
<p>The computation uses the FFT by calling the function <code class="code">fftfilt</code>.  If
the optional argument <var class="var">n</var> is specified, an N-point FFT is used.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Products-of-Polynomials.html#XREFdeconv">deconv</a>, <a class="ref" href="Products-of-Polynomials.html#XREFconv">conv</a>, <a class="ref" href="Products-of-Polynomials.html#XREFconv2">conv2</a>.
</p></dd></dl>


<a class="anchor" id="XREFfftfilt"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fftfilt"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftfilt</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-fftfilt"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftfilt-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftfilt</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-fftfilt-1"> &para;</a></span></dt>
<dd><p>Filter <var class="var">x</var> with the FIR filter <var class="var">b</var> using the FFT.
</p>
<p>If <var class="var">x</var> is a matrix, filter each column of the matrix.
</p>
<p>Given the optional third argument, <var class="var">n</var>, <code class="code">fftfilt</code> uses the
overlap-add method to filter <var class="var">x</var> with <var class="var">b</var> using an N-point FFT.
The FFT size must be an even power of 2 and must be greater than or equal to
the length of <var class="var">b</var>.  If the specified <var class="var">n</var> does not meet these
criteria, it is automatically adjusted to the nearest value that does.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfilter">filter</a>, <a class="ref" href="#XREFfilter2">filter2</a>.
</p></dd></dl>


<a class="anchor" id="XREFfilter"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-filter"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-filter"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-filter-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">sf</var>] =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>, <var class="var">si</var>)</code><a class="copiable-link" href="#index-filter-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-filter-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">sf</var>] =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>, [], <var class="var">dim</var>)</code><a class="copiable-link" href="#index-filter-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-filter-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">sf</var>] =</code> <strong class="def-name">filter</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">x</var>, <var class="var">si</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-filter-3"> &para;</a></span></dt>
<dd><p>Apply a 1-D digital filter to the data <var class="var">x</var>.
</p>
<p><code class="code">filter</code> returns the solution to the following linear, time-invariant
difference equation:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted"> N                   M
SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1&lt;=n&lt;=length(x)
k=0                 k=0
</pre></div></div>


<p>where
N=length(a)-1 and M=length(b)-1.
The result is calculated over the first non-singleton dimension of <var class="var">x</var>
or over <var class="var">dim</var> if supplied.
</p>
<p>An equivalent form of the equation is:
</p>
<div class="example smallexample">
<div class="group"><pre class="example-preformatted">          N                   M
y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&lt;=n&lt;=length(x)
         k=1                 k=0
</pre></div></div>


<p>where
 c = a/a(1) and d = b/a(1).
</p>
<p>If the fourth argument <var class="var">si</var> is provided, it is taken as the
initial state of the system and the final state is returned as
<var class="var">sf</var>.  The state vector is a column vector whose length is
equal to the length of the longest coefficient vector minus one.
If <var class="var">si</var> is not supplied, the initial state vector is set to all
zeros.
</p>
<p>In terms of the Z Transform, <var class="var">y</var> is the result of passing the
discrete-time signal <var class="var">x</var> through a system characterized by the following
rational system function:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">          M
         SUM d(k+1) z^(-k)
         k=0
H(z) = ---------------------
            N
       1 + SUM c(k+1) z^(-k)
           k=1
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfilter2">filter2</a>, <a class="ref" href="#XREFfftfilt">fftfilt</a>, <a class="ref" href="#XREFfreqz">freqz</a>.
</p></dd></dl>


<a class="anchor" id="XREFfilter2"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-filter2"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">filter2</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>)</code><a class="copiable-link" href="#index-filter2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-filter2-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">filter2</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">x</var>, <var class="var">shape</var>)</code><a class="copiable-link" href="#index-filter2-1"> &para;</a></span></dt>
<dd><p>Apply the 2-D FIR filter <var class="var">b</var> to <var class="var">x</var>.
</p>
<p>If the argument <var class="var">shape</var> is specified, return an array of the desired
shape.  Possible values are:
</p>
<dl class="table">
<dt><code class="code">&quot;full&quot;</code></dt>
<dd><p>pad <var class="var">x</var> with zeros on all sides before filtering.
</p>
</dd>
<dt><code class="code">&quot;same&quot;</code></dt>
<dd><p>unpadded <var class="var">x</var> (default)
</p>
</dd>
<dt><code class="code">&quot;valid&quot;</code></dt>
<dd><p>trim <var class="var">x</var> after filtering so edge effects are no included.
</p></dd>
</dl>

<p>Note this is just a variation on convolution, with the parameters reversed
and <var class="var">b</var> rotated 180 degrees.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Products-of-Polynomials.html#XREFconv2">conv2</a>.
</p></dd></dl>


<a class="anchor" id="XREFfreqz"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-freqz"><span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">n</var>, &quot;whole&quot;)</code><a class="copiable-link" href="#index-freqz"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>)</code><a class="copiable-link" href="#index-freqz-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>)</code><a class="copiable-link" href="#index-freqz-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-freqz-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">h</var> =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(<var class="var">b</var>, <var class="var">a</var>, <var class="var">w</var>)</code><a class="copiable-link" href="#index-freqz-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-5"><span class="category-def">: </span><span><code class="def-type">[<var class="var">h</var>, <var class="var">w</var>] =</code> <strong class="def-name">freqz</strong> <code class="def-code-arguments">(&hellip;, <var class="var">Fs</var>)</code><a class="copiable-link" href="#index-freqz-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz-6"><span class="category-def">: </span><span><strong class="def-name">freqz</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-freqz-6"> &para;</a></span></dt>
<dd>
<p>Return the complex frequency response <var class="var">h</var> of the rational IIR filter
whose numerator and denominator coefficients are <var class="var">b</var> and <var class="var">a</var>,
respectively.
</p>
<p>The response is evaluated at <var class="var">n</var> angular frequencies between 0 and
2*pi.
</p>
<p>The output value <var class="var">w</var> is a vector of the frequencies.
</p>
<p>If <var class="var">a</var> is omitted, the denominator is assumed to be 1 (this
corresponds to a simple FIR filter).
</p>
<p>If <var class="var">n</var> is omitted, a value of 512 is assumed.  For fastest computation,
<var class="var">n</var> should factor into a small number of small primes.
</p>
<p>If the fourth argument, <code class="code">&quot;whole&quot;</code>, is omitted the response is
evaluated at frequencies between 0 and
pi.
</p>
<p><code class="code">freqz (<var class="var">b</var>, <var class="var">a</var>, <var class="var">w</var>)</code>
</p>
<p>Evaluate the response at the specific frequencies in the vector <var class="var">w</var>.
The values for <var class="var">w</var> are measured in radians.
</p>
<p><code class="code">[&hellip;] = freqz (&hellip;, <var class="var">Fs</var>)</code>
</p>
<p>Return frequencies in Hz instead of radians assuming a sampling rate
<var class="var">Fs</var>.  If you are evaluating the response at specific frequencies
<var class="var">w</var>, those frequencies should be requested in Hz rather than radians.
</p>
<p><code class="code">freqz (&hellip;)</code>
</p>
<p>Plot the magnitude and phase response of <var class="var">h</var> rather than returning them.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfreqz_005fplot">freqz_plot</a>.
</p></dd></dl>


<a class="anchor" id="XREFfreqz_005fplot"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-freqz_005fplot"><span class="category-def">: </span><span><strong class="def-name">freqz_plot</strong> <code class="def-code-arguments">(<var class="var">w</var>, <var class="var">h</var>)</code><a class="copiable-link" href="#index-freqz_005fplot"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-freqz_005fplot-1"><span class="category-def">: </span><span><strong class="def-name">freqz_plot</strong> <code class="def-code-arguments">(<var class="var">w</var>, <var class="var">h</var>, <var class="var">freq_norm</var>)</code><a class="copiable-link" href="#index-freqz_005fplot-1"> &para;</a></span></dt>
<dd><p>Plot the magnitude and phase response of <var class="var">h</var>.
</p>
<p>If the optional <var class="var">freq_norm</var> argument is true, the frequency vector
<var class="var">w</var> is in units of normalized radians.  If <var class="var">freq_norm</var> is false, or
not given, then <var class="var">w</var> is measured in Hertz.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfreqz">freqz</a>.
</p></dd></dl>


<a class="anchor" id="XREFsinc"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-sinc"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinc</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-sinc"> &para;</a></span></dt>
<dd><p>Compute the sinc function.
</p>
<p>Return
sin (pi*x) / (pi*x).
</p></dd></dl>


<a class="anchor" id="XREFunwrap"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-unwrap"><span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">unwrap</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-unwrap"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-unwrap-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">unwrap</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-unwrap-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-unwrap-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">b</var> =</code> <strong class="def-name">unwrap</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">tol</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-unwrap-2"> &para;</a></span></dt>
<dd><p>Unwrap radian phases by adding or subtracting multiples of 2*pi as
appropriate to remove jumps greater than <var class="var">tol</var>.
</p>
<p><var class="var">tol</var> defaults to pi.
</p>
<p><code class="code">unwrap</code> will work along the dimension <var class="var">dim</var>.  If <var class="var">dim</var>
is unspecified it defaults to the first non-singleton dimension.
</p>
<p><code class="code">unwrap</code> ignores all non-finite input values (Inf, NaN, NA).
</p>
</dd></dl>



<a class="anchor" id="XREFarch_005ffit"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-arch_005ffit"><span class="category-def">: </span><span><code class="def-type">[<var class="var">a</var>, <var class="var">b</var>] =</code> <strong class="def-name">arch_fit</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">x</var>, <var class="var">p</var>, <var class="var">iter</var>, <var class="var">gamma</var>, <var class="var">a0</var>, <var class="var">b0</var>)</code><a class="copiable-link" href="#index-arch_005ffit"> &para;</a></span></dt>
<dd><p>Fit an ARCH regression model to the time series <var class="var">y</var> using the scoring
algorithm in Engle&rsquo;s original ARCH paper.
</p>
<p>The model is
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(p+1) * e(t-p)^2
</pre></div></div>

<p>in which <em class="math">e(t)</em> is <em class="math">N(0, h(t))</em>, given a time-series vector
<var class="var">y</var> up to time <em class="math">t-1</em> and a matrix of (ordinary) regressors <var class="var">x</var>
up to <em class="math">t</em>.  The order of the regression of the residual variance is
specified by <var class="var">p</var>.
</p>
<p>If invoked as <code class="code">arch_fit (<var class="var">y</var>, <var class="var">k</var>, <var class="var">p</var>)</code> with a positive
integer <var class="var">k</var>, fit an ARCH(<var class="var">k</var>, <var class="var">p</var>) process, i.e., do the above
with the <em class="math">t</em>-th row of <var class="var">x</var> given by
</p>
<div class="example">
<pre class="example-preformatted">[1, y(t-1), ..., y(t-k)]
</pre></div>

<p>Optionally, one can specify the number of iterations <var class="var">iter</var>, the
updating factor <var class="var">gamma</var>, and initial values <em class="math">a0</em> and <em class="math">b0</em>
for the scoring algorithm.
</p></dd></dl>


<a class="anchor" id="XREFarch_005frnd"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-arch_005frnd"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">arch_rnd</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-arch_005frnd"> &para;</a></span></dt>
<dd><p>Simulate an ARCH sequence of length <var class="var">t</var> with AR coefficients <var class="var">b</var> and
CH coefficients <var class="var">a</var>.
</p>
<p>The result <em class="math">y(t)</em> follows the model
</p>
<div class="example smallexample">
<pre class="example-preformatted">y(t) = b(1) + b(2) * y(t-1) + ... + b(lb) * y(t-lb+1) + e(t),
</pre></div>

<p>where <em class="math">e(t)</em>, given <var class="var">y</var> up to time <em class="math">t-1</em>, is
<em class="math">N(0, h(t))</em>, with
</p>
<div class="example smallexample">
<pre class="example-preformatted">h(t) = a(1) + a(2) * e(t-1)^2 + ... + a(la) * e(t-la+1)^2
</pre></div>
</dd></dl>


<a class="anchor" id="XREFarch_005ftest"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-arch_005ftest"><span class="category-def">: </span><span><code class="def-type">[<var class="var">pval</var>, <var class="var">lm</var>] =</code> <strong class="def-name">arch_test</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-arch_005ftest"> &para;</a></span></dt>
<dd><p>For a linear regression model
</p>
<div class="example">
<pre class="example-preformatted">y = x * b + e
</pre></div>

<p>perform a Lagrange Multiplier (LM) test of the null hypothesis of no
conditional heteroscedascity against the alternative of CH(<var class="var">p</var>).
</p>
<p>I.e., the model is
</p>
<div class="example">
<pre class="example-preformatted">y(t) = b(1) * x(t,1) + ... + b(k) * x(t,k) + e(t),
</pre></div>

<p>given <var class="var">y</var> up to <em class="math">t-1</em> and <var class="var">x</var> up to <em class="math">t</em>,
<em class="math">e</em>(t) is <em class="math">N(0, h(t))</em> with
</p>
<div class="example">
<pre class="example-preformatted">h(t) = v + a(1) * e(t-1)^2 + ... + a(p) * e(t-p)^2,
</pre></div>

<p>and the null is <em class="math">a(1)</em> == &hellip; == <em class="math">a(p)</em> == 0.
</p>
<p>If the second argument is a scalar integer, <em class="math">k</em>, perform the same
test in a linear autoregression model of order <em class="math">k</em>, i.e., with
</p>
<div class="example">
<pre class="example-preformatted">[1, y(t-1), ..., y(t-<var class="var">k</var>)]
</pre></div>

<p>as the <em class="math">t</em>-th row of <var class="var">x</var>.
</p>
<p>Under the null, LM approximately has a chisquare distribution with
<var class="var">p</var> degrees of freedom and <var class="var">pval</var> is the <em class="math">p</em>-value (1
minus the CDF of this distribution at LM) of the test.
</p>
<p>If no output argument is given, the <em class="math">p</em>-value is displayed.
</p></dd></dl>


<a class="anchor" id="XREFarma_005frnd"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-arma_005frnd"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">arma_rnd</strong> <code class="def-code-arguments">(<var class="var">a</var>, <var class="var">b</var>, <var class="var">v</var>, <var class="var">t</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-arma_005frnd"> &para;</a></span></dt>
<dd><p>Return a simulation of the ARMA model.
</p>
<p>The ARMA model is defined by
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">x(n) = a(1) * x(n-1) + ... + a(k) * x(n-k)
     + e(n) + b(1) * e(n-1) + ... + b(l) * e(n-l)
</pre></div></div>

<p>in which <var class="var">k</var> is the length of vector <var class="var">a</var>, <var class="var">l</var> is the length of
vector <var class="var">b</var> and <var class="var">e</var> is Gaussian white noise with variance <var class="var">v</var>.
The function returns a vector of length <var class="var">t</var>.
</p>
<p>The optional parameter <var class="var">n</var> gives the number of dummy <var class="var">x</var>(<var class="var">i</var>)
used for initialization, i.e., a sequence of length <var class="var">t</var>+<var class="var">n</var> is
generated and <var class="var">x</var>(<var class="var">n</var>+1:<var class="var">t</var>+<var class="var">n</var>) is returned.  If <var class="var">n</var>
is omitted, <var class="var">n</var> = 100 is used.
</p></dd></dl>


<a class="anchor" id="XREFautoreg_005fmatrix"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-autoreg_005fmatrix"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">autoreg_matrix</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-autoreg_005fmatrix"> &para;</a></span></dt>
<dd><p>Given a time series (vector) <var class="var">y</var>, return a matrix with ones in the first
column and the first <var class="var">k</var> lagged values of <var class="var">y</var> in the other columns.
</p>
<p>In other words, for <var class="var">t</var> &gt; <var class="var">k</var>,
<code class="code">[1, <var class="var">y</var>(<var class="var">t</var>-1), &hellip;, <var class="var">y</var>(<var class="var">t</var>-<var class="var">k</var>)]</code> is the
t-th row of the result.
</p>
<p>The resulting matrix may be used as a regressor matrix in autoregressions.
</p></dd></dl>


<a class="anchor" id="XREFbartlett"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-bartlett"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">bartlett</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-bartlett"> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Bartlett (triangular) window of length
<var class="var">m</var>.
</p>
<p>For a definition of the Bartlett window see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite class="cite">Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<a class="anchor" id="XREFblackman"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-blackman"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">blackman</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-blackman"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-blackman-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">blackman</strong> <code class="def-code-arguments">(<var class="var">m</var>, &quot;periodic&quot;)</code><a class="copiable-link" href="#index-blackman-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-blackman-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">blackman</strong> <code class="def-code-arguments">(<var class="var">m</var>, &quot;symmetric&quot;)</code><a class="copiable-link" href="#index-blackman-2"> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Blackman window of length
<var class="var">m</var>.
</p>
<p>If the optional argument <code class="code">&quot;periodic&quot;</code> is given, the periodic form
of the window is returned.  This is equivalent to the window of length
<var class="var">m</var>+1 with the last coefficient removed.  The optional argument
<code class="code">&quot;symmetric&quot;</code> is equivalent to not specifying a second argument.
</p>
<p>For a definition of the Blackman window, see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite class="cite">Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<a class="anchor" id="XREFdetrend"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-detrend"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">detrend</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">p</var>)</code><a class="copiable-link" href="#index-detrend"> &para;</a></span></dt>
<dd><p>If <var class="var">x</var> is a vector, <code class="code">detrend (<var class="var">x</var>, <var class="var">p</var>)</code> removes the
best fit of a polynomial of order <var class="var">p</var> from the data <var class="var">x</var>.
</p>
<p>If <var class="var">x</var> is a matrix, <code class="code">detrend (<var class="var">x</var>, <var class="var">p</var>)</code> does the same
for each column in <var class="var">x</var>.
</p>
<p>The second argument <var class="var">p</var> is optional.  If it is not specified, a value of
1 is assumed.  This corresponds to removing a linear trend.
</p>
<p>The order of the polynomial can also be given as a string, in which case
<var class="var">p</var> must be either <code class="code">&quot;constant&quot;</code> (corresponds to <code class="code"><var class="var">p</var>=0</code>)
or <code class="code">&quot;linear&quot;</code> (corresponds to <code class="code"><var class="var">p</var>=1</code>).
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Polynomial-Interpolation.html#XREFpolyfit">polyfit</a>.
</p></dd></dl>


<a class="anchor" id="XREFdiffpara"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-diffpara"><span class="category-def">: </span><span><code class="def-type">[<var class="var">d</var>, <var class="var">dd</var>] =</code> <strong class="def-name">diffpara</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">a</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-diffpara"> &para;</a></span></dt>
<dd><p>Return the estimator <var class="var">d</var> for the differencing parameter of an
integrated time series.
</p>
<p>The frequencies from <em class="math">[2*pi*a/t, 2*pi*b/T]</em> are used for the
estimation.  If <var class="var">b</var> is omitted, the interval
<em class="math">[2*pi/T, 2*pi*a/T]</em> is used.  If both <var class="var">b</var> and <var class="var">a</var> are omitted
then <em class="math">a = 0.5 * sqrt (T)</em> and <em class="math">b = 1.5 * sqrt (T)</em> is used, where
<em class="math">T</em> is the sample size.  If <var class="var">x</var> is a matrix, the differencing
parameter of each column is estimated.
</p>
<p>The estimators for all frequencies in the intervals described above is
returned in <var class="var">dd</var>.
</p>
<p>The value of <var class="var">d</var> is simply the mean of <var class="var">dd</var>.
</p>
<p>Reference: P.J. Brockwell &amp; R.A. Davis. <cite class="cite">Time Series:
Theory and Methods</cite>. Springer 1987.
</p></dd></dl>


<a class="anchor" id="XREFdurbinlevinson"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-durbinlevinson"><span class="category-def">: </span><span><code class="def-type">[<var class="var">newphi</var>, <var class="var">newv</var>] =</code> <strong class="def-name">durbinlevinson</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">oldphi</var>, <var class="var">oldv</var>)</code><a class="copiable-link" href="#index-durbinlevinson"> &para;</a></span></dt>
<dd><p>Perform one step of the Durbin-Levinson algorithm.
</p>
<p>The vector <var class="var">c</var> specifies the autocovariances
<code class="code">[gamma_0, &hellip;, gamma_t]</code> from lag 0 to <var class="var">t</var>, <var class="var">oldphi</var>
specifies the coefficients based on <var class="var">c</var>(<var class="var">t</var>-1) and <var class="var">oldv</var>
specifies the corresponding error.
</p>
<p>If <var class="var">oldphi</var> and <var class="var">oldv</var> are omitted, all steps from 1 to <var class="var">t</var> of
the algorithm are performed.
</p></dd></dl>


<a class="anchor" id="XREFfftshift"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fftshift"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftshift</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-fftshift"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-fftshift-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">fftshift</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-fftshift-1"> &para;</a></span></dt>
<dd><p>Perform a shift of the vector <var class="var">x</var>, for use with the <code class="code">fft</code> and
<code class="code">ifft</code> functions, in order to move the frequency 0 to the center of
the vector or matrix.
</p>
<p>If <var class="var">x</var> is a vector of <em class="math">N</em> elements corresponding to <em class="math">N</em> time
samples spaced by <em class="math">dt</em>, then
<code class="code">fftshift (fft (<var class="var">x</var>))</code> corresponds to frequencies
</p>
<div class="example">
<pre class="example-preformatted">f = [ -(ceil((N-1)/2):-1:1), 0, (1:floor((N-1)/2)) ] * df
</pre></div>

<p>where <em class="math">df = 1 / (N * dt)</em>.
</p>
<p>If <var class="var">x</var> is a matrix, the same holds for rows and columns.  If <var class="var">x</var>
is an array, then the same holds along each dimension.
</p>
<p>The optional <var class="var">dim</var> argument can be used to limit the dimension along
which the permutation occurs.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFifftshift">ifftshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFifftshift"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ifftshift"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifftshift</strong> <code class="def-code-arguments">(<var class="var">y</var>)</code><a class="copiable-link" href="#index-ifftshift"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ifftshift-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">ifftshift</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-ifftshift-1"> &para;</a></span></dt>
<dd><p>Undo the action of the <code class="code">fftshift</code> function.
</p>
<p>For even length <var class="var">x</var>, <code class="code">fftshift</code> is its own inverse, but odd lengths
differ slightly.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfftshift">fftshift</a>.
</p></dd></dl>


<a class="anchor" id="XREFfractdiff"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-fractdiff"><span class="category-def">: </span><span><code class="def-type"><var class="var">fd</var> =</code> <strong class="def-name">fractdiff</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-fractdiff"> &para;</a></span></dt>
<dd><p>Compute the fractional differences <em class="math">(1-L)^d x</em> where <em class="math">L</em>
denotes the lag-operator and <em class="math">d</em> is greater than -1.
</p></dd></dl>


<a class="anchor" id="XREFhamming"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-hamming"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hamming</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-hamming"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-hamming-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hamming</strong> <code class="def-code-arguments">(<var class="var">m</var>, &quot;periodic&quot;)</code><a class="copiable-link" href="#index-hamming-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-hamming-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hamming</strong> <code class="def-code-arguments">(<var class="var">m</var>, &quot;symmetric&quot;)</code><a class="copiable-link" href="#index-hamming-2"> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Hamming window of length <var class="var">m</var>.
</p>
<p>If the optional argument <code class="code">&quot;periodic&quot;</code> is given, the periodic form
of the window is returned.  This is equivalent to the window of length
<var class="var">m</var>+1 with the last coefficient removed.  The optional argument
<code class="code">&quot;symmetric&quot;</code> is equivalent to not specifying a second argument.
</p>
<p>For a definition of the Hamming window see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite class="cite">Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<a class="anchor" id="XREFhanning"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-hanning"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hanning</strong> <code class="def-code-arguments">(<var class="var">m</var>)</code><a class="copiable-link" href="#index-hanning"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-hanning-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hanning</strong> <code class="def-code-arguments">(<var class="var">m</var>, &quot;periodic&quot;)</code><a class="copiable-link" href="#index-hanning-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-hanning-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">c</var> =</code> <strong class="def-name">hanning</strong> <code class="def-code-arguments">(<var class="var">m</var>, &quot;symmetric&quot;)</code><a class="copiable-link" href="#index-hanning-2"> &para;</a></span></dt>
<dd><p>Return the filter coefficients of a Hanning window of length <var class="var">m</var>.
</p>
<p>If the optional argument <code class="code">&quot;periodic&quot;</code> is given, the periodic form
of the window is returned.  This is equivalent to the window of length
<var class="var">m</var>+1 with the last coefficient removed.  The optional argument
<code class="code">&quot;symmetric&quot;</code> is equivalent to not specifying a second argument.
</p>
<p>For a definition of the Hanning window see, e.g.,
A.V. Oppenheim &amp; R. W. Schafer,
<cite class="cite">Discrete-Time Signal Processing</cite>.
</p></dd></dl>


<a class="anchor" id="XREFhurst"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-hurst"><span class="category-def">: </span><span><code class="def-type"><var class="var">H</var> =</code> <strong class="def-name">hurst</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-hurst"> &para;</a></span></dt>
<dd><p>Estimate the Hurst parameter of sample <var class="var">x</var> via the rescaled range
statistic.
</p>
<p>If <var class="var">x</var> is a matrix, the parameter is estimated for every column.
</p></dd></dl>


<a class="anchor" id="XREFpchip"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-pchip"><span class="category-def">: </span><span><code class="def-type"><var class="var">pp</var> =</code> <strong class="def-name">pchip</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-pchip"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-pchip-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">pchip</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-pchip-1"> &para;</a></span></dt>
<dd><p>Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of
points <var class="var">x</var> and <var class="var">y</var>.
</p>
<p>If called with two arguments, return the piecewise polynomial <var class="var">pp</var>
that may be used with <code class="code">ppval</code> to evaluate the polynomial at specific
points.
</p>
<p>When called with a third input argument, <code class="code">pchip</code> evaluates the pchip
polynomial at the points <var class="var">xi</var>.  The third calling form is equivalent to
<code class="code">ppval (pchip (<var class="var">x</var>, <var class="var">y</var>), <var class="var">xi</var>)</code>.
</p>
<p>The variable <var class="var">x</var> must be a strictly monotonic vector (either increasing
or decreasing) of length <var class="var">n</var>.
</p>
<p><var class="var">y</var> can be either a vector or array.  If <var class="var">y</var> is a vector then it
must be the same length <var class="var">n</var> as <var class="var">x</var>.  If <var class="var">y</var> is an array then
the size of <var class="var">y</var> must have the form
<code class="code">[<var class="var">s1</var>, <var class="var">s2</var>, &hellip;, <var class="var">sk</var>, <var class="var">n</var>]</code>
The array is reshaped internally to a matrix where the leading dimension is
given by
<code class="code"><var class="var">s1</var> * <var class="var">s2</var> * &hellip; * <var class="var">sk</var></code>
and each row of this matrix is then treated separately.  Note that this is
exactly opposite to <code class="code">interp1</code> but is done for <small class="sc">MATLAB</small>
compatibility.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="One_002ddimensional-Interpolation.html#XREFspline">spline</a>, <a class="ref" href="Polynomial-Interpolation.html#XREFppval">ppval</a>, <a class="ref" href="Polynomial-Interpolation.html#XREFmkpp">mkpp</a>, <a class="ref" href="Polynomial-Interpolation.html#XREFunmkpp">unmkpp</a>.
</p></dd></dl>


<a class="anchor" id="XREFperiodogram"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-periodogram"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">w</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-periodogram"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-1"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">w</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>)</code><a class="copiable-link" href="#index-periodogram-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">w</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>, <var class="var">nfft</var>)</code><a class="copiable-link" href="#index-periodogram-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-3"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">f</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>, <var class="var">nfft</var>, <var class="var">Fs</var>)</code><a class="copiable-link" href="#index-periodogram-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-4"><span class="category-def">: </span><span><code class="def-type">[<var class="var">Pxx</var>, <var class="var">f</var>] =</code> <strong class="def-name">periodogram</strong> <code class="def-code-arguments">(&hellip;, &quot;<var class="var">range</var>&quot;)</code><a class="copiable-link" href="#index-periodogram-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-periodogram-5"><span class="category-def">: </span><span><strong class="def-name">periodogram</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-periodogram-5"> &para;</a></span></dt>
<dd><p>Return the periodogram (Power Spectral Density) of <var class="var">x</var>.
</p>
<p>The possible inputs are:
</p>
<dl class="table">
<dt><var class="var">x</var></dt>
<dd>
<p>data vector.  If <var class="var">x</var> is real-valued a one-sided spectrum is estimated.
If <var class="var">x</var> is complex-valued, or <code class="code">&quot;<var class="var">range</var>&quot;</code> specifies
<code class="code">&quot;twosided&quot;</code>, the full spectrum is estimated.
</p>
</dd>
<dt><var class="var">win</var></dt>
<dd><p>window weight data.  If window is empty or unspecified a default rectangular
window is used.  Otherwise, the window is applied to the signal
(<code class="code"><var class="var">x</var> .* <var class="var">win</var></code>) before computing the periodogram.  The window
data must be a vector of the same length as <var class="var">x</var>.
</p>
</dd>
<dt><var class="var">nfft</var></dt>
<dd><p>number of frequency bins.  The default is 256 or the next higher power of
2 greater than the length of <var class="var">x</var>
(<code class="code">max (256, 2.^nextpow2 (length (x)))</code>).  If <var class="var">nfft</var> is greater
than the length of the input then <var class="var">x</var> will be zero-padded to the length
of <var class="var">nfft</var>.
</p>
</dd>
<dt><var class="var">Fs</var></dt>
<dd><p>sampling rate.  The default is 1.
</p>
</dd>
<dt><var class="var">range</var></dt>
<dd><p>range of spectrum.  <code class="code">&quot;onesided&quot;</code> computes spectrum from
[0:nfft/2+1].  <code class="code">&quot;twosided&quot;</code> computes spectrum from
[0:nfft-1].
</p></dd>
</dl>

<p>The optional second output <var class="var">w</var> are the normalized angular frequencies.
For a one-sided calculation <var class="var">w</var> is in the range [0, pi] if <var class="var">nfft</var>
is even and [0, pi) if <var class="var">nfft</var> is odd.  Similarly, for a two-sided
calculation <var class="var">w</var> is in the range [0, 2*pi] or [0, 2*pi) depending on
<var class="var">nfft</var>.
</p>
<p>If a sampling frequency is specified, <var class="var">Fs</var>, then the output frequencies
<var class="var">f</var> will be in the range [0, <var class="var">Fs</var>/2] or [0, <var class="var">Fs</var>/2) for
one-sided calculations.  For two-sided calculations the range will be
[0, <var class="var">Fs</var>).
</p>
<p>When called with no outputs the periodogram is immediately plotted in the
current figure window.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFfft">fft</a>.
</p></dd></dl>


<a class="anchor" id="XREFsinetone"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-sinetone"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinetone</strong> <code class="def-code-arguments">(<var class="var">freq</var>, <var class="var">rate</var>, <var class="var">sec</var>, <var class="var">ampl</var>)</code><a class="copiable-link" href="#index-sinetone"> &para;</a></span></dt>
<dd><p>Return a sinetone of frequency <var class="var">freq</var> with a length of <var class="var">sec</var>
seconds at sampling rate <var class="var">rate</var> and with amplitude <var class="var">ampl</var>.
</p>
<p>The arguments <var class="var">freq</var> and <var class="var">ampl</var> may be vectors of common size.
</p>
<p>The defaults are <var class="var">rate</var> = 8000, <var class="var">sec</var> = 1, and <var class="var">ampl</var> = 64.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsinewave">sinewave</a>.
</p></dd></dl>


<a class="anchor" id="XREFsinewave"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-sinewave"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">sinewave</strong> <code class="def-code-arguments">(<var class="var">m</var>, <var class="var">n</var>, <var class="var">d</var>)</code><a class="copiable-link" href="#index-sinewave"> &para;</a></span></dt>
<dd><p>Return an <var class="var">m</var>-element vector with <var class="var">i</var>-th element given by
<code class="code">sin (2 * pi * (<var class="var">i</var>+<var class="var">d</var>-1) / <var class="var">n</var>)</code>.
</p>
<p>The default value for <var class="var">d</var> is 0 and the default value for <var class="var">n</var> is
<var class="var">m</var>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsinetone">sinetone</a>.
</p></dd></dl>


<a class="anchor" id="XREFspectral_005fadf"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-spectral_005fadf"><span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_adf</strong> <code class="def-code-arguments">(<var class="var">c</var>)</code><a class="copiable-link" href="#index-spectral_005fadf"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fadf-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_adf</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">win</var>)</code><a class="copiable-link" href="#index-spectral_005fadf-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fadf-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_adf</strong> <code class="def-code-arguments">(<var class="var">c</var>, <var class="var">win</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-spectral_005fadf-2"> &para;</a></span></dt>
<dd><p>Return the spectral density estimator given a vector of autocovariances
<var class="var">c</var>, window name <var class="var">win</var>, and bandwidth, <var class="var">b</var>.
</p>
<p>The window name, e.g., <code class="code">&quot;triangle&quot;</code> or <code class="code">&quot;rectangle&quot;</code> is
used to search for a function called <code class="code"><var class="var">win</var>_lw</code>.
</p>
<p>If <var class="var">win</var> is omitted, the triangle window is used.
</p>
<p>If <var class="var">b</var> is omitted, <code class="code">1 / sqrt (length (<var class="var">x</var>))</code> is used.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFspectral_005fxdf">spectral_xdf</a>.
</p></dd></dl>


<a class="anchor" id="XREFspectral_005fxdf"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-spectral_005fxdf"><span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_xdf</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-spectral_005fxdf"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fxdf-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_xdf</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>)</code><a class="copiable-link" href="#index-spectral_005fxdf-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spectral_005fxdf-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">sde</var> =</code> <strong class="def-name">spectral_xdf</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win</var>, <var class="var">b</var>)</code><a class="copiable-link" href="#index-spectral_005fxdf-2"> &para;</a></span></dt>
<dd><p>Return the spectral density estimator given a data vector <var class="var">x</var>, window
name <var class="var">win</var>, and bandwidth, <var class="var">b</var>.
</p>
<p>The window name, e.g., <code class="code">&quot;triangle&quot;</code> or <code class="code">&quot;rectangle&quot;</code> is used to
search for a function called <code class="code"><var class="var">win</var>_sw</code>.
</p>
<p>If <var class="var">win</var> is omitted, the triangle window is used.
</p>
<p>If <var class="var">b</var> is omitted, <code class="code">1 / sqrt (length (<var class="var">x</var>))</code> is used.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFspectral_005fadf">spectral_adf</a>.
</p></dd></dl>


<a class="anchor" id="XREFspencer"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-spencer"><span class="category-def">: </span><span><code class="def-type"><var class="var">savg</var> =</code> <strong class="def-name">spencer</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-spencer"> &para;</a></span></dt>
<dd><p>Return Spencer&rsquo;s 15-point moving average of each column of
<var class="var">x</var>.
</p></dd></dl>


<a class="anchor" id="XREFstft"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-stft"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>)</code><a class="copiable-link" href="#index-stft"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-stft-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>)</code><a class="copiable-link" href="#index-stft-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-stft-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>, <var class="var">inc</var>)</code><a class="copiable-link" href="#index-stft-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-stft-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>, <var class="var">inc</var>, <var class="var">num_coef</var>)</code><a class="copiable-link" href="#index-stft-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-stft-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">win_size</var>, <var class="var">inc</var>, <var class="var">num_coef</var>, <var class="var">win_type</var>)</code><a class="copiable-link" href="#index-stft-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-stft-5"><span class="category-def">: </span><span><code class="def-type">[<var class="var">y</var>, <var class="var">c</var>] =</code> <strong class="def-name">stft</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-stft-5"> &para;</a></span></dt>
<dd><p>Compute the short-time Fourier transform of the vector <var class="var">x</var> with
<var class="var">num_coef</var> coefficients by applying a window of <var class="var">win_size</var> data
points and an increment of <var class="var">inc</var> points.
</p>
<p>Before computing the Fourier transform, one of the following windows
is applied:
</p>
<dl class="table">
<dt><code class="code">&quot;hanning&quot;</code></dt>
<dd><p>win_type = 1
</p>
</dd>
<dt><code class="code">&quot;hamming&quot;</code></dt>
<dd><p>win_type = 2
</p>
</dd>
<dt><code class="code">&quot;rectangle&quot;</code></dt>
<dd><p>win_type = 3
</p></dd>
</dl>

<p>The window names can be passed as strings or by the <var class="var">win_type</var> number.
</p>
<p>The following defaults are used for unspecified arguments:
<var class="var">win_size</var> = 80, <var class="var">inc</var> = 24, <var class="var">num_coef</var> = 64, and
<var class="var">win_type</var> = 1.
</p>
<p><code class="code"><var class="var">y</var> = stft (<var class="var">x</var>, &hellip;)</code> returns the absolute values of the
Fourier coefficients according to the <var class="var">num_coef</var> positive frequencies.
</p>
<p><code class="code">[<var class="var">y</var>, <var class="var">c</var>] = stft (<var class="var">x</var>, &hellip;)</code> returns the entire
STFT-matrix <var class="var">y</var> and a 3-element vector <var class="var">c</var> containing the window
size, increment, and window type, which is needed by the <code class="code">synthesis</code>
function.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFsynthesis">synthesis</a>.
</p></dd></dl>


<a class="anchor" id="XREFsynthesis"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-synthesis"><span class="category-def">: </span><span><code class="def-type"><var class="var">x</var> =</code> <strong class="def-name">synthesis</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-synthesis"> &para;</a></span></dt>
<dd><p>Compute a signal from its short-time Fourier transform <var class="var">y</var> and a
3-element vector <var class="var">c</var> specifying window size, increment, and window type.
</p>
<p>The values <var class="var">y</var> and <var class="var">c</var> can be derived by
</p>
<div class="example">
<pre class="example-preformatted">[<var class="var">y</var>, <var class="var">c</var>] = stft (<var class="var">x</var> , ...)
</pre></div>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFstft">stft</a>.
</p></dd></dl>


<a class="anchor" id="XREFyulewalker"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-yulewalker"><span class="category-def">: </span><span><code class="def-type">[<var class="var">a</var>, <var class="var">v</var>] =</code> <strong class="def-name">yulewalker</strong> <code class="def-code-arguments">(<var class="var">c</var>)</code><a class="copiable-link" href="#index-yulewalker"> &para;</a></span></dt>
<dd><p>Fit an AR (p)-model with Yule-Walker estimates given a vector <var class="var">c</var> of
autocovariances <code class="code">[gamma_0, &hellip;, gamma_p]</code>.
</p>
<p>Returns the AR coefficients, <var class="var">a</var>, and the variance of white noise,
<var class="var">v</var>.
</p></dd></dl>



</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Image-Processing.html">Image Processing</a>, Previous: <a href="Geometry.html">Geometry</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
