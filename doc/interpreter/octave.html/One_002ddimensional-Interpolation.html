<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>One-dimensional Interpolation (GNU Octave (version 9.2.0))</title>

<meta name="description" content="One-dimensional Interpolation (GNU Octave (version 9.2.0))">
<meta name="keywords" content="One-dimensional Interpolation (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Interpolation.html" rel="up" title="Interpolation">
<link href="Multi_002ddimensional-Interpolation.html" rel="next" title="Multi-dimensional Interpolation">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.center {text-align:center}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="One_002ddimensional-Interpolation">
<div class="nav-panel">
<p>
Next: <a href="Multi_002ddimensional-Interpolation.html" accesskey="n" rel="next">Multi-dimensional Interpolation</a>, Up: <a href="Interpolation.html" accesskey="u" rel="up">Interpolation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="One_002ddimensional-Interpolation-1"><span>29.1 One-dimensional Interpolation<a class="copiable-link" href="#One_002ddimensional-Interpolation-1"> &para;</a></span></h3>

<p>Octave supports several methods for one-dimensional interpolation, most
of which are described in this section.  <a class="ref" href="Polynomial-Interpolation.html">Polynomial Interpolation</a>
and <a class="ref" href="Interpolation-on-Scattered-Data.html">Interpolation on Scattered Data</a> describe additional methods.
</p>
<a class="anchor" id="XREFinterp1"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-interp1"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-interp1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interp1-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(<var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-interp1-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interp1-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(&hellip;, <var class="var">method</var>)</code><a class="copiable-link" href="#index-interp1-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interp1-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(&hellip;, <var class="var">extrap</var>)</code><a class="copiable-link" href="#index-interp1-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interp1-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(&hellip;, &quot;left&quot;)</code><a class="copiable-link" href="#index-interp1-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interp1-5"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(&hellip;, &quot;right&quot;)</code><a class="copiable-link" href="#index-interp1-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interp1-6"><span class="category-def">: </span><span><code class="def-type"><var class="var">pp</var> =</code> <strong class="def-name">interp1</strong> <code class="def-code-arguments">(&hellip;, &quot;pp&quot;)</code><a class="copiable-link" href="#index-interp1-6"> &para;</a></span></dt>
<dd>
<p>One-dimensional interpolation.
</p>
<p>Interpolate input data to determine the value of <var class="var">yi</var> at the points
<var class="var">xi</var>.  If not specified, <var class="var">x</var> is taken to be the indices of <var class="var">y</var>
(<code class="code">1:length (<var class="var">y</var>)</code>).  If <var class="var">y</var> is a matrix or an N-dimensional
array, the interpolation is performed on each column of <var class="var">y</var>.
</p>
<p>The interpolation <var class="var">method</var> is one of:
</p>
<dl class="table">
<dt><code class="code">&quot;nearest&quot;</code></dt>
<dd><p>Return the nearest neighbor.
</p>
</dd>
<dt><code class="code">&quot;previous&quot;</code></dt>
<dd><p>Return the previous neighbor.
</p>
</dd>
<dt><code class="code">&quot;next&quot;</code></dt>
<dd><p>Return the next neighbor.
</p>
</dd>
<dt><code class="code">&quot;linear&quot;</code> (default)</dt>
<dd><p>Linear interpolation from nearest neighbors.
</p>
</dd>
<dt><code class="code">&quot;pchip&quot;</code></dt>
<dd><p>Piecewise cubic Hermite interpolating polynomial&mdash;shape-preserving
interpolation with smooth first derivative.
</p>
</dd>
<dt><code class="code">&quot;cubic&quot;</code></dt>
<dd><p>Cubic interpolation (same as <code class="code">&quot;pchip&quot;</code>).
</p>
</dd>
<dt><code class="code">&quot;spline&quot;</code></dt>
<dd><p>Cubic spline interpolation&mdash;smooth first and second derivatives
throughout the curve.
</p></dd>
</dl>

<p>Adding &rsquo;*&rsquo; to the start of any method above forces <code class="code">interp1</code>
to assume that <var class="var">x</var> is uniformly spaced, and only <code class="code"><var class="var">x</var>(1)</code>
and <code class="code"><var class="var">x</var>(2)</code> are referenced.  This is usually faster,
and is never slower.  The default method is <code class="code">&quot;linear&quot;</code>.
</p>
<p>If <var class="var">extrap</var> is the string <code class="code">&quot;extrap&quot;</code>, then extrapolate values
beyond the endpoints using the current <var class="var">method</var>.  If <var class="var">extrap</var> is a
number, then replace values beyond the endpoints with that number.  When
unspecified, <var class="var">extrap</var> defaults to <code class="code">NA</code>.
</p>
<p>If the string argument <code class="code">&quot;pp&quot;</code> is specified, then <var class="var">xi</var> should not
be supplied and <code class="code">interp1</code> returns a piecewise polynomial object.  This
object can later be used with <code class="code">ppval</code> to evaluate the interpolation.
There is an equivalence, such that <code class="code">ppval (interp1 (<var class="var">x</var>,
<var class="var">y</var>, <var class="var">method</var>, <code class="code">&quot;pp&quot;</code>), <var class="var">xi</var>) == interp1 (<var class="var">x</var>,
<var class="var">y</var>, <var class="var">xi</var>, <var class="var">method</var>, <code class="code">&quot;extrap&quot;</code>)</code>.
</p>
<p>Duplicate points in <var class="var">x</var> specify a discontinuous interpolant.  There
may be at most 2 consecutive points with the same value.
If <var class="var">x</var> is increasing, the default discontinuous interpolant is
right-continuous.  If <var class="var">x</var> is decreasing, the default discontinuous
interpolant is left-continuous.
The continuity condition of the interpolant may be specified by using
the options <code class="code">&quot;left&quot;</code> or <code class="code">&quot;right&quot;</code> to select a left-continuous
or right-continuous interpolant, respectively.
Discontinuous interpolation is only allowed for <code class="code">&quot;nearest&quot;</code> and
<code class="code">&quot;linear&quot;</code> methods; in all other cases, the <var class="var">x</var>-values must be
unique.
</p>
<p>An example of the use of <code class="code">interp1</code> is
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">xf = [0:0.05:10];
yf = sin (2*pi*xf/5);
xp = [0:10];
yp = sin (2*pi*xp/5);
lin = interp1 (xp, yp, xf);
near = interp1 (xp, yp, xf, &quot;nearest&quot;);
pch = interp1 (xp, yp, xf, &quot;pchip&quot;);
spl = interp1 (xp, yp, xf, &quot;spline&quot;);
plot (xf,yf,&quot;r&quot;, xf,near,&quot;g&quot;, xf,lin,&quot;b&quot;, xf,pch,&quot;c&quot;, xf,spl,&quot;m&quot;,
      xp,yp,&quot;r*&quot;);
legend (&quot;original&quot;, &quot;nearest&quot;, &quot;linear&quot;, &quot;pchip&quot;, &quot;spline&quot;);
</pre></div></div>


<p><strong class="strong">See also:</strong> <a class="ref" href="Signal-Processing.html#XREFpchip">pchip</a>, <a class="ref" href="#XREFspline">spline</a>, <a class="ref" href="#XREFinterpft">interpft</a>, <a class="ref" href="Multi_002ddimensional-Interpolation.html#XREFinterp2">interp2</a>, <a class="ref" href="Multi_002ddimensional-Interpolation.html#XREFinterp3">interp3</a>, <a class="ref" href="Multi_002ddimensional-Interpolation.html#XREFinterpn">interpn</a>.
</p></dd></dl>


<p>There are some important differences between the various interpolation
methods.  The <code class="code">&quot;spline&quot;</code> method enforces that both the first and second
derivatives of the interpolated values have a continuous derivative,
whereas the other methods do not.  This means that the results of the
<code class="code">&quot;spline&quot;</code> method are generally smoother.  If the function to be
interpolated is in fact smooth, then <code class="code">&quot;spline&quot;</code> will give excellent
results.  However, if the function to be evaluated is in some manner
discontinuous, then <code class="code">&quot;pchip&quot;</code> interpolation might give better results.
</p>
<p>This can be demonstrated by the code
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">t = -2:2;
dt = 1;
ti =-2:0.025:2;
dti = 0.025;
y = sign (t);
ys = interp1 (t,y,ti,&quot;spline&quot;);
yp = interp1 (t,y,ti,&quot;pchip&quot;);
ddys = diff (diff (ys)./dti) ./ dti;
ddyp = diff (diff (yp)./dti) ./ dti;
figure (1);
plot (ti,ys,&quot;r-&quot;, ti,yp,&quot;g-&quot;);
legend (&quot;spline&quot;, &quot;pchip&quot;, 4);
figure (2);
plot (ti,ddys,&quot;r+&quot;, ti,ddyp,&quot;g*&quot;);
legend (&quot;spline&quot;, &quot;pchip&quot;);
</pre></div></div>

<p>The result of which can be seen in <a class="ref" href="#fig_003ainterpderiv1">Figure 29.1</a> and
<a class="ref" href="#fig_003ainterpderiv2">Figure 29.2</a>.
</p>
<div class="float" id="fig_003ainterpderiv1">
<div class="center"><img class="image" src="interpderiv1.png" alt="interpderiv1">
</div><div class="caption"><p><strong class="strong">Figure 29.1: </strong>Comparison of <code class="code">&quot;pchip&quot;</code> and <code class="code">&quot;spline&quot;</code> interpolation methods for a
step function</p></div></div>
<div class="float" id="fig_003ainterpderiv2">
<div class="center"><img class="image" src="interpderiv2.png" alt="interpderiv2">
</div><div class="caption"><p><strong class="strong">Figure 29.2: </strong>Comparison of the second derivative of the <code class="code">&quot;pchip&quot;</code> and <code class="code">&quot;spline&quot;</code>
interpolation methods for a step function</p></div></div>
<p>Fourier interpolation, is a resampling technique where a signal is
converted to the frequency domain, padded with zeros and then
reconverted to the time domain.
</p>
<a class="anchor" id="XREFinterpft"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-interpft"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">interpft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-interpft"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-interpft-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">y</var> =</code> <strong class="def-name">interpft</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">n</var>, <var class="var">dim</var>)</code><a class="copiable-link" href="#index-interpft-1"> &para;</a></span></dt>
<dd>
<p>Fourier interpolation.
</p>
<p>If <var class="var">x</var> is a vector then <var class="var">x</var> is resampled with <var class="var">n</var> points.  The
data in <var class="var">x</var> is assumed to be equispaced.  If <var class="var">x</var> is a matrix or an
N-dimensional array, the interpolation is performed on each column of
<var class="var">x</var>.
</p>
<p>If <var class="var">dim</var> is specified, then interpolate along the dimension <var class="var">dim</var>.
</p>
<p><code class="code">interpft</code> assumes that the interpolated function is periodic, and so
assumptions are made about the endpoints of the interpolation.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFinterp1">interp1</a>.
</p></dd></dl>


<p>There are two significant limitations on Fourier interpolation.  First,
the function signal is assumed to be periodic, and so non-periodic
signals will be poorly represented at the edges.  Second, both the
signal and its interpolation are required to be sampled at equispaced
points.  An example of the use of <code class="code">interpft</code> is
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">t = 0 : 0.3 : pi; dt = t(2)-t(1);
n = length (t); k = 100;
ti = t(1) + [0 : k-1]*dt*n/k;
y = sin (4*t + 0.3) .* cos (3*t - 0.1);
yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
plot (ti, yp, &quot;g&quot;, ti, interp1 (t, y, ti, &quot;spline&quot;), &quot;b&quot;, ...
      ti, interpft (y, k), &quot;c&quot;, t, y, &quot;r+&quot;);
legend (&quot;sin(4t+0.3)cos(3t-0.1)&quot;, &quot;spline&quot;, &quot;interpft&quot;, &quot;data&quot;);
</pre></div></div>

<p>which demonstrates the poor behavior of Fourier interpolation for non-periodic
functions, as can be seen in <a class="ref" href="#fig_003ainterpft">Figure 29.3</a>.
</p>
<div class="float" id="fig_003ainterpft">
<div class="center"><img class="image" src="interpft.png" alt="interpft">
</div><div class="caption"><p><strong class="strong">Figure 29.3: </strong>Comparison of <code class="code">interp1</code> and <code class="code">interpft</code> for non-periodic data</p></div></div>
<p>In addition, the support functions <code class="code">spline</code> and <code class="code">lookup</code> that
underlie the <code class="code">interp1</code> function can be called directly.
</p>
<a class="anchor" id="XREFspline"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-spline"><span class="category-def">: </span><span><code class="def-type"><var class="var">pp</var> =</code> <strong class="def-name">spline</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="#index-spline"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spline-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">yi</var> =</code> <strong class="def-name">spline</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code><a class="copiable-link" href="#index-spline-1"> &para;</a></span></dt>
<dd><p>Return the cubic spline interpolant of points <var class="var">x</var> and <var class="var">y</var>.
</p>
<p>When called with two arguments, return the piecewise polynomial <var class="var">pp</var>
that may be used with <code class="code">ppval</code> to evaluate the polynomial at specific
points.
</p>
<p>When called with a third input argument, <code class="code">spline</code> evaluates the spline
at the points <var class="var">xi</var>.  The third calling form
<code class="code">spline (<var class="var">x</var>, <var class="var">y</var>, <var class="var">xi</var>)</code> is equivalent to
<code class="code">ppval (spline (<var class="var">x</var>, <var class="var">y</var>), <var class="var">xi</var>)</code>.
</p>
<p>The variable <var class="var">x</var> must be a vector of length <var class="var">n</var>.
</p>
<p><var class="var">y</var> can be either a vector or array.  If <var class="var">y</var> is a vector it must
have a length of either <var class="var">n</var> or <code class="code"><var class="var">n</var> + 2</code>.  If the length of
<var class="var">y</var> is <var class="var">n</var>, then the <code class="code">&quot;not-a-knot&quot;</code> end condition is used.
If the length of <var class="var">y</var> is <code class="code"><var class="var">n</var> + 2</code>, then the first and last
values of the vector <var class="var">y</var> are the values of the first derivative of the
cubic spline at the endpoints.
</p>
<p>If <var class="var">y</var> is an array, then the size of <var class="var">y</var> must have the form
<code class="code">[<var class="var">s1</var>, <var class="var">s2</var>, &hellip;, <var class="var">sk</var>, <var class="var">n</var>]</code>
or
<code class="code">[<var class="var">s1</var>, <var class="var">s2</var>, &hellip;, <var class="var">sk</var>, <var class="var">n</var> + 2]</code>.
The array is reshaped internally to a matrix where the leading
dimension is given by
<code class="code"><var class="var">s1</var> * <var class="var">s2</var> * &hellip; * <var class="var">sk</var></code>
and each row of this matrix is then treated separately.  Note that this is
exactly the opposite of <code class="code">interp1</code> but is done for <small class="sc">MATLAB</small>
compatibility.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="Signal-Processing.html#XREFpchip">pchip</a>, <a class="ref" href="Polynomial-Interpolation.html#XREFppval">ppval</a>, <a class="ref" href="Polynomial-Interpolation.html#XREFmkpp">mkpp</a>, <a class="ref" href="Polynomial-Interpolation.html#XREFunmkpp">unmkpp</a>.
</p></dd></dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Multi_002ddimensional-Interpolation.html">Multi-dimensional Interpolation</a>, Up: <a href="Interpolation.html">Interpolation</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
