<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Sparse Linear Algebra (GNU Octave (version 9.2.0))</title>

<meta name="description" content="Sparse Linear Algebra (GNU Octave (version 9.2.0))">
<meta name="keywords" content="Sparse Linear Algebra (GNU Octave (version 9.2.0))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Sparse-Matrices.html" rel="up" title="Sparse Matrices">
<link href="Iterative-Techniques.html" rel="next" title="Iterative Techniques">
<link href="Basics.html" rel="prev" title="Basics">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
ul.mark-minus {list-style-type: "\2212"}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Sparse-Linear-Algebra">
<div class="nav-panel">
<p>
Next: <a href="Iterative-Techniques.html" accesskey="n" rel="next">Iterative Techniques Applied to Sparse Matrices</a>, Previous: <a href="Basics.html" accesskey="p" rel="prev">Creation and Manipulation of Sparse Matrices</a>, Up: <a href="Sparse-Matrices.html" accesskey="u" rel="up">Sparse Matrices</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Linear-Algebra-on-Sparse-Matrices"><span>22.2 Linear Algebra on Sparse Matrices<a class="copiable-link" href="#Linear-Algebra-on-Sparse-Matrices"> &para;</a></span></h3>

<p>Octave includes a polymorphic solver for sparse matrices, where
the exact solver used to factorize the matrix, depends on the properties
of the sparse matrix itself.  Generally, the cost of determining the matrix
type is small relative to the cost of factorizing the matrix itself, but in
any case the matrix type is cached once it is calculated, so that it is not
re-determined each time it is used in a linear equation.
</p>
<p>The selection tree for how the linear equation is solve is
</p>
<ol class="enumerate">
<li> If the matrix is diagonal, solve directly and goto 8

</li><li> If the matrix is a permuted diagonal, solve directly taking into
account the permutations.  Goto 8

</li><li> If the matrix is square, banded and if the band density is less
than that given by <code class="code">spparms (&quot;bandden&quot;)</code> continue, else goto 4.

<ol class="enumerate" type="a" start="1">
<li> If the matrix is tridiagonal and the right-hand side is not sparse
continue, else goto 3b.

<ol class="enumerate">
<li> If the matrix is Hermitian, with a positive real diagonal, attempt
      Cholesky&nbsp;factorization using <small class="sc">LAPACK</small> xPTSV.

</li><li> If the above failed or the matrix is not Hermitian with a positive
      real diagonal use Gaussian elimination with pivoting using
      <small class="sc">LAPACK</small> xGTSV, and goto 8.
</li></ol>

</li><li> If the matrix is Hermitian with a positive real diagonal, attempt
      Cholesky&nbsp;factorization using <small class="sc">LAPACK</small> xPBTRF.

</li><li> if the above failed or the matrix is not Hermitian with a positive
      real diagonal use Gaussian elimination with pivoting using
      <small class="sc">LAPACK</small> xGBTRF, and goto 8.
</li></ol>

</li><li> If the matrix is upper or lower triangular perform a sparse forward
or backward substitution, and goto 8

</li><li> If the matrix is an upper triangular matrix with column permutations
or lower triangular matrix with row permutations, perform a sparse forward
or backward substitution, and goto 8

</li><li> If the matrix is square, Hermitian with a real positive diagonal, attempt
sparse Cholesky&nbsp;factorization using <small class="sc">CHOLMOD</small>.

</li><li> If the sparse Cholesky&nbsp;factorization failed or the matrix is not
Hermitian with a real positive diagonal, and the matrix is square, factorize,
solve, and perform one refinement iteration using <small class="sc">UMFPACK</small>.

</li><li> If the matrix is not square, or any of the previous solvers flags
a singular or near singular matrix, find a minimum norm solution using
<small class="sc">CXSPARSE</small><a class="footnote" id="DOCF10" href="#FOOT10"><sup>10</sup></a>.
</li></ol>

<p>The band density is defined as the number of nonzero values in the band
divided by the total number of values in the full band.  The banded
matrix solvers can be entirely disabled by using <em class="dfn">spparms</em> to set
<code class="code">bandden</code> to 1 (i.e., <code class="code">spparms (&quot;bandden&quot;, 1)</code>).
</p>
<p>The QR&nbsp;solver factorizes the problem with a Dulmage-Mendelsohn
decomposition, to separate the problem into blocks that can be treated
as over-determined, multiple well determined blocks, and a final
over-determined block.  For matrices with blocks of strongly connected
nodes this is a big win as LU&nbsp;decomposition can be used for many
blocks.  It also significantly improves the chance of finding a solution
to over-determined problems rather than just returning a vector of
<em class="dfn">NaN</em>&rsquo;s.
</p>
<p>All of the solvers above, can calculate an estimate of the condition
number.  This can be used to detect numerical stability problems in the
solution and force a minimum norm solution to be used.  However, for
narrow banded, triangular or diagonal matrices, the cost of
calculating the condition number is significant, and can in fact
exceed the cost of factoring the matrix.  Therefore the condition
number is not calculated in these cases, and Octave relies on simpler
techniques to detect singular matrices or the underlying <small class="sc">LAPACK</small> code in
the case of banded matrices.
</p>
<p>The user can force the type of the matrix with the <code class="code">matrix_type</code>
function.  This overcomes the cost of discovering the type of the matrix.
However, it should be noted that identifying the type of the matrix incorrectly
will lead to unpredictable results, and so <code class="code">matrix_type</code> should be
used with care.
</p>
<a class="anchor" id="XREFnormest"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-normest"><span class="category-def">: </span><span><code class="def-type"><var class="var">nest</var> =</code> <strong class="def-name">normest</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-normest"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">nest</var> =</code> <strong class="def-name">normest</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">tol</var>)</code><a class="copiable-link" href="#index-normest-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">nest</var>, <var class="var">iter</var>] =</code> <strong class="def-name">normest</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-normest-2"> &para;</a></span></dt>
<dd><p>Estimate the 2-norm of the matrix <var class="var">A</var> using a power series analysis.
</p>
<p>This is typically used for large matrices, where the cost of calculating
<code class="code">norm (<var class="var">A</var>)</code> is prohibitive and an approximation to the 2-norm is
acceptable.
</p>
<p><var class="var">tol</var> is the tolerance to which the 2-norm is calculated.  By default
<var class="var">tol</var> is 1e-6.
</p>
<p>The optional output <var class="var">iter</var> returns the number of iterations that were
required for <code class="code">normest</code> to converge.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFnormest1">normest1</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFnorm">norm</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFcond">cond</a>, <a class="ref" href="#XREFcondest">condest</a>.
</p></dd></dl>


<a class="anchor" id="XREFnormest1"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-normest1"><span class="category-def">: </span><span><code class="def-type"><var class="var">nest</var> =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-normest1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest1-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">nest</var> =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-normest1-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest1-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">nest</var> =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">t</var>, <var class="var">x0</var>)</code><a class="copiable-link" href="#index-normest1-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest1-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">nest</var> =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">Afcn</var>, <var class="var">t</var>, <var class="var">x0</var>, <var class="var">p1</var>, <var class="var">p2</var>, &hellip;)</code><a class="copiable-link" href="#index-normest1-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest1-4"><span class="category-def">: </span><span><code class="def-type">[<var class="var">nest</var>, <var class="var">v</var>] =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">A</var>, &hellip;)</code><a class="copiable-link" href="#index-normest1-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest1-5"><span class="category-def">: </span><span><code class="def-type">[<var class="var">nest</var>, <var class="var">v</var>, <var class="var">w</var>] =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">A</var>, &hellip;)</code><a class="copiable-link" href="#index-normest1-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-normest1-6"><span class="category-def">: </span><span><code class="def-type">[<var class="var">nest</var>, <var class="var">v</var>, <var class="var">w</var>, <var class="var">iter</var>] =</code> <strong class="def-name">normest1</strong> <code class="def-code-arguments">(<var class="var">A</var>, &hellip;)</code><a class="copiable-link" href="#index-normest1-6"> &para;</a></span></dt>
<dd><p>Estimate the 1-norm of the matrix <var class="var">A</var> using a block algorithm.
</p>
<p><code class="code">normest1</code> is best for large sparse matrices where only an estimate of
the norm is required.  For small to medium sized matrices, consider using
<code class="code">norm (<var class="var">A</var>, 1)</code>.  In addition, <code class="code">normest1</code> can be used for the
estimate of the 1-norm of a linear operator <var class="var">A</var> when matrix-vector
products <code class="code"><var class="var">A</var> * <var class="var">x</var></code> and <code class="code"><var class="var">A</var>' * <var class="var">x</var></code> can be
cheaply computed.  In this case, instead of the matrix <var class="var">A</var>, a function
<code class="code"><var class="var">Afcn</var> (<var class="var">flag</var>, <var class="var">x</var>)</code> is used; it must return:
</p>
<ul class="itemize mark-bullet">
<li>the dimension <var class="var">n</var> of <var class="var">A</var>, if <var class="var">flag</var> is <code class="code">&quot;dim&quot;</code>

</li><li>true if <var class="var">A</var> is a real operator, if <var class="var">flag</var> is <code class="code">&quot;real&quot;</code>

</li><li>the result <code class="code"><var class="var">A</var> * <var class="var">x</var></code>, if <var class="var">flag</var> is <code class="code">&quot;notransp&quot;</code>

</li><li>the result <code class="code"><var class="var">A</var>' * <var class="var">x</var></code>, if <var class="var">flag</var> is <code class="code">&quot;transp&quot;</code>
</li></ul>

<p>A typical case is <var class="var">A</var> defined by <code class="code"><var class="var">b</var> ^ <var class="var">m</var></code>, in which the
result <code class="code"><var class="var">A</var> * <var class="var">x</var></code> can be computed without even forming
explicitly <code class="code"><var class="var">b</var> ^ <var class="var">m</var></code> by:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"><var class="var">y</var> = <var class="var">x</var>;
for <var class="var">i</var> = 1:<var class="var">m</var>
  <var class="var">y</var> = <var class="var">b</var> * <var class="var">y</var>;
endfor
</pre></div></div>

<p>The parameters <var class="var">p1</var>, <var class="var">p2</var>, &hellip; are arguments of
<code class="code"><var class="var">Afcn</var> (<var class="var">flag</var>, <var class="var">x</var>, <var class="var">p1</var>, <var class="var">p2</var>, &hellip;)</code>.
</p>
<p>The default value for <var class="var">t</var> is 2.  The algorithm requires matrix-matrix
products with sizes <var class="var">n</var> x <var class="var">n</var> and <var class="var">n</var> x <var class="var">t</var>.
</p>
<p>The initial matrix <var class="var">x0</var> should have columns of unit 1-norm.  The default
initial matrix <var class="var">x0</var> has the first column
<code class="code">ones (<var class="var">n</var>, 1) / <var class="var">n</var></code> and, if <var class="var">t</var> &gt; 1, the remaining
columns with random elements <code class="code">-1 / <var class="var">n</var></code>, <code class="code">1 / <var class="var">n</var></code>,
divided by <var class="var">n</var>.
</p>
<p>On output, <var class="var">nest</var> is the desired estimate, <var class="var">v</var> and <var class="var">w</var>
are vectors such that <code class="code"><var class="var">w</var> = <var class="var">A</var> * <var class="var">v</var></code>, with
<code class="code">norm (<var class="var">w</var>, 1)</code> = <code class="code"><var class="var">c</var> * norm (<var class="var">v</var>, 1)</code>.  <var class="var">iter</var>
contains in <code class="code"><var class="var">iter</var>(1)</code> the number of iterations (the maximum is
hardcoded to 5) and in <code class="code"><var class="var">iter</var>(2)</code> the total number of products
<code class="code"><var class="var">A</var> * <var class="var">x</var></code> or <code class="code"><var class="var">A</var>' * <var class="var">x</var></code> performed by the
algorithm.
</p>
<p>Algorithm Note: <code class="code">normest1</code> uses random numbers during evaluation.
Therefore, if consistent results are required, the <code class="code">&quot;state&quot;</code> of the
random generator should be fixed before invoking <code class="code">normest1</code>.
</p>
<p>Reference: N. J. Higham and F. Tisseur,
<cite class="cite">A block algorithm for matrix 1-norm estimation, with and
application to 1-norm pseudospectra</cite>,
SIAM J. Matrix Anal. Appl.,
pp. 1185&ndash;1201, Vol 21, No. 4, 2000.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="#XREFnormest">normest</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFnorm">norm</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFcond">cond</a>, <a class="ref" href="#XREFcondest">condest</a>.
</p></dd></dl>


<a class="anchor" id="XREFcondest"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-condest"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-condest"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-condest-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">Ainvfcn</var>)</code><a class="copiable-link" href="#index-condest-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">Ainvfcn</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-condest-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">Ainvfcn</var>, <var class="var">t</var>, <var class="var">p1</var>, <var class="var">p2</var>, &hellip;)</code><a class="copiable-link" href="#index-condest-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-5"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">Afcn</var>, <var class="var">Ainvfcn</var>)</code><a class="copiable-link" href="#index-condest-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-6"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">Afcn</var>, <var class="var">Ainvfcn</var>, <var class="var">t</var>)</code><a class="copiable-link" href="#index-condest-6"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-7"><span class="category-def">: </span><span><code class="def-type"><var class="var">cest</var> =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(<var class="var">Afcn</var>, <var class="var">Ainvfcn</var>, <var class="var">t</var>, <var class="var">p1</var>, <var class="var">p2</var>, &hellip;)</code><a class="copiable-link" href="#index-condest-7"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-condest-8"><span class="category-def">: </span><span><code class="def-type">[<var class="var">cest</var>, <var class="var">v</var>] =</code> <strong class="def-name">condest</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-condest-8"> &para;</a></span></dt>
<dd>
<p>Estimate the 1-norm condition number of a square matrix <var class="var">A</var> using
<var class="var">t</var> test vectors and a randomized 1-norm estimator.
</p>
<p>The optional input <var class="var">t</var> specifies the number of test vectors (default 5).
</p>
<p>The input may be a matrix <var class="var">A</var> (the algorithm is particularly
appropriate for large, sparse matrices).  Alternatively, the behavior of
the matrix can be defined implicitly by functions.  When using an implicit
definition, <code class="code">condest</code> requires the following functions:
</p>
<ul class="itemize mark-minus">
<li><code class="code"><var class="var">Afcn</var> (<var class="var">flag</var>, <var class="var">x</var>)</code> which must return

<ul class="itemize mark-bullet">
<li>the dimension <var class="var">n</var> of <var class="var">A</var>, if <var class="var">flag</var> is <code class="code">&quot;dim&quot;</code>

</li><li>true if <var class="var">A</var> is a real operator, if <var class="var">flag</var> is <code class="code">&quot;real&quot;</code>

</li><li>the result <code class="code"><var class="var">A</var> * <var class="var">x</var></code>, if <var class="var">flag</var> is &quot;notransp&quot;

</li><li>the result <code class="code"><var class="var">A</var>' * <var class="var">x</var></code>, if <var class="var">flag</var> is &quot;transp&quot;
</li></ul>

</li><li><code class="code"><var class="var">Ainvfcn</var> (<var class="var">flag</var>, <var class="var">x</var>)</code> which must return

<ul class="itemize mark-bullet">
<li>the dimension <var class="var">n</var> of <code class="code">inv (<var class="var">A</var>)</code>, if <var class="var">flag</var> is
<code class="code">&quot;dim&quot;</code>

</li><li>true if <code class="code">inv (<var class="var">A</var>)</code> is a real operator, if <var class="var">flag</var> is
<code class="code">&quot;real&quot;</code>

</li><li>the result <code class="code">inv (<var class="var">A</var>) * <var class="var">x</var></code>, if <var class="var">flag</var> is &quot;notransp&quot;

</li><li>the result <code class="code">inv (<var class="var">A</var>)' * <var class="var">x</var></code>, if <var class="var">flag</var> is &quot;transp&quot;
</li></ul>
</li></ul>

<p>Any parameters <var class="var">p1</var>, <var class="var">p2</var>, &hellip; are additional arguments of
<code class="code"><var class="var">Afcn</var> (<var class="var">flag</var>, <var class="var">x</var>, <var class="var">p1</var>, <var class="var">p2</var>, &hellip;)</code>
and <code class="code"><var class="var">Ainvfcn</var> (<var class="var">flag</var>, <var class="var">x</var>, <var class="var">p1</var>, <var class="var">p2</var>, &hellip;)</code>.
</p>
<p>The principal output is the 1-norm condition number estimate <var class="var">cest</var>.
</p>
<p>The optional second output <var class="var">v</var> is an approximate null vector; it
satisfies the equation <code class="code">norm (<var class="var">A</var>*<var class="var">v</var>, 1) ==
norm (<var class="var">A</var>, 1) * norm (<var class="var">v</var>, 1) / <var class="var">cest</var></code>.
</p>
<p>Algorithm Note: <code class="code">condest</code> uses a randomized algorithm to approximate
the 1-norms.  Therefore, if consistent results are required, the
<code class="code">&quot;state&quot;</code> of the random generator should be fixed before invoking
<code class="code">condest</code>.
</p>
<p>References:
</p>
<ul class="itemize mark-bullet">
<li>N.J. Higham and F. Tisseur, <cite class="cite">A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra</cite>.  SIMAX vol 21, no 4, pp 1185&ndash;1201.
<a class="url" href="https://dx.doi.org/10.1137/S0895479899356080">https://dx.doi.org/10.1137/S0895479899356080</a>

</li><li>N.J. Higham and F. Tisseur, <cite class="cite">A Block Algorithm
for Matrix 1-Norm Estimation, with an Application to 1-Norm
Pseudospectra</cite>.  <a class="url" href="https://citeseer.ist.psu.edu/223007.html">https://citeseer.ist.psu.edu/223007.html</a>
</li></ul>


<p><strong class="strong">See also:</strong> <a class="ref" href="Basic-Matrix-Functions.html#XREFcond">cond</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFrcond">rcond</a>, <a class="ref" href="Basic-Matrix-Functions.html#XREFnorm">norm</a>, <a class="ref" href="#XREFnormest1">normest1</a>, <a class="ref" href="#XREFnormest">normest</a>.
</p></dd></dl>


<a class="anchor" id="XREFspparms"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-spparms"><span class="category-def">: </span><span><strong class="def-name">spparms</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-spparms"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">vals</var> =</code> <strong class="def-name">spparms</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-spparms-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-2"><span class="category-def">: </span><span><code class="def-type">[<var class="var">keys</var>, <var class="var">vals</var>] =</code> <strong class="def-name">spparms</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="#index-spparms-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">val</var> =</code> <strong class="def-name">spparms</strong> <code class="def-code-arguments">(<var class="var">key</var>)</code><a class="copiable-link" href="#index-spparms-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-4"><span class="category-def">: </span><span><strong class="def-name">spparms</strong> <code class="def-code-arguments">(<var class="var">vals</var>)</code><a class="copiable-link" href="#index-spparms-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-5"><span class="category-def">: </span><span><strong class="def-name">spparms</strong> <code class="def-code-arguments">(&quot;default&quot;)</code><a class="copiable-link" href="#index-spparms-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-6"><span class="category-def">: </span><span><strong class="def-name">spparms</strong> <code class="def-code-arguments">(&quot;tight&quot;)</code><a class="copiable-link" href="#index-spparms-6"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-spparms-7"><span class="category-def">: </span><span><strong class="def-name">spparms</strong> <code class="def-code-arguments">(<var class="var">key</var>, <var class="var">val</var>)</code><a class="copiable-link" href="#index-spparms-7"> &para;</a></span></dt>
<dd><p>Query or set the parameters used by the sparse solvers and factorization
functions.
</p>
<p>The first four calls above get information about the current settings, while
the others change the current settings.  The parameters are stored as pairs
of keys and values, where the values are all floats and the keys are one of
the following strings:
</p>
<dl class="table">
<dt>&lsquo;<samp class="samp">spumoni</samp>&rsquo;</dt>
<dd><p>Printing level of debugging information of the solvers (default 0)
</p>
</dd>
<dt>&lsquo;<samp class="samp">ths_rel</samp>&rsquo;</dt>
<dd><p>Included for compatibility.  Not used.  (default 1)
</p>
</dd>
<dt>&lsquo;<samp class="samp">ths_abs</samp>&rsquo;</dt>
<dd><p>Included for compatibility.  Not used.  (default 1)
</p>
</dd>
<dt>&lsquo;<samp class="samp">exact_d</samp>&rsquo;</dt>
<dd><p>Included for compatibility.  Not used.  (default 0)
</p>
</dd>
<dt>&lsquo;<samp class="samp">supernd</samp>&rsquo;</dt>
<dd><p>Included for compatibility.  Not used.  (default 3)
</p>
</dd>
<dt>&lsquo;<samp class="samp">rreduce</samp>&rsquo;</dt>
<dd><p>Included for compatibility.  Not used.  (default 3)
</p>
</dd>
<dt>&lsquo;<samp class="samp">wh_frac</samp>&rsquo;</dt>
<dd><p>Included for compatibility.  Not used.  (default 0.5)
</p>
</dd>
<dt>&lsquo;<samp class="samp">autommd</samp>&rsquo;</dt>
<dd><p>Flag whether the LU/QR and the &rsquo;\&rsquo; and &rsquo;/&rsquo; operators will automatically
use the sparsity preserving mmd functions (default 1)
</p>
</dd>
<dt>&lsquo;<samp class="samp">autoamd</samp>&rsquo;</dt>
<dd><p>Flag whether the LU and the &rsquo;\&rsquo; and &rsquo;/&rsquo; operators will automatically
use the sparsity preserving amd functions (default 1)
</p>
</dd>
<dt>&lsquo;<samp class="samp">piv_tol</samp>&rsquo;</dt>
<dd><p>The pivot tolerance of the <small class="sc">UMFPACK</small> solvers (default 0.1)
</p>
</dd>
<dt>&lsquo;<samp class="samp">sym_tol</samp>&rsquo;</dt>
<dd><p>The pivot tolerance of the <small class="sc">UMFPACK</small> symmetric solvers (default 0.001)
</p>
</dd>
<dt>&lsquo;<samp class="samp">bandden</samp>&rsquo;</dt>
<dd><p>The density of nonzero elements in a banded matrix before it is treated
by the <small class="sc">LAPACK</small> banded solvers (default 0.5)
</p>
</dd>
<dt>&lsquo;<samp class="samp">umfpack</samp>&rsquo;</dt>
<dd><p>Flag whether the <small class="sc">UMFPACK</small> or mmd solvers are used for the LU, &rsquo;\&rsquo; and
&rsquo;/&rsquo; operations (default 1)
</p></dd>
</dl>

<p>The value of individual keys can be set with
<code class="code">spparms (<var class="var">key</var>, <var class="var">val</var>)</code>.
The default values can be restored with the special keyword
<code class="code">&quot;default&quot;</code>.  The special keyword <code class="code">&quot;tight&quot;</code> can be used to
set the mmd solvers to attempt a sparser solution at the potential cost of
longer running time.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Matrix-Factorizations.html#XREFchol">chol</a>, <a class="ref" href="Mathematical-Considerations.html#XREFcolamd">colamd</a>, <a class="ref" href="Matrix-Factorizations.html#XREFlu">lu</a>, <a class="ref" href="Matrix-Factorizations.html#XREFqr">qr</a>, <a class="ref" href="Mathematical-Considerations.html#XREFsymamd">symamd</a>.
</p></dd></dl>


<a class="anchor" id="XREFsprank"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-sprank"><span class="category-def">: </span><span><code class="def-type"><var class="var">p</var> =</code> <strong class="def-name">sprank</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-sprank"> &para;</a></span></dt>
<dd><a class="index-entry-id" id="index-structural-rank"></a>

<p>Calculate the structural rank of the sparse matrix <var class="var">S</var>.
</p>
<p>Note that only the structure of the matrix is used in this calculation based
on a Dulmage-Mendelsohn permutation to block triangular form.  As
such the numerical rank of the matrix <var class="var">S</var> is bounded by
<code class="code">sprank (<var class="var">S</var>) &gt;= rank (<var class="var">S</var>)</code>.  Ignoring floating point errors
<code class="code">sprank (<var class="var">S</var>) == rank (<var class="var">S</var>)</code>.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Mathematical-Considerations.html#XREFdmperm">dmperm</a>.
</p></dd></dl>


<a class="anchor" id="XREFsymbfact"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-symbfact"><span class="category-def">: </span><span><code class="def-type">[<var class="var">count</var>, <var class="var">h</var>, <var class="var">parent</var>, <var class="var">post</var>, <var class="var">R</var>] =</code> <strong class="def-name">symbfact</strong> <code class="def-code-arguments">(<var class="var">S</var>)</code><a class="copiable-link" href="#index-symbfact"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-symbfact-1"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">symbfact</strong> <code class="def-code-arguments">(<var class="var">S</var>, <var class="var">typ</var>)</code><a class="copiable-link" href="#index-symbfact-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-symbfact-2"><span class="category-def">: </span><span><code class="def-type">[&hellip;] =</code> <strong class="def-name">symbfact</strong> <code class="def-code-arguments">(<var class="var">S</var>, <var class="var">typ</var>, <var class="var">mode</var>)</code><a class="copiable-link" href="#index-symbfact-2"> &para;</a></span></dt>
<dd>
<p>Perform a symbolic factorization analysis of the sparse matrix <var class="var">S</var>.
</p>
<p>The input variables are
</p>
<dl class="table">
<dt><var class="var">S</var></dt>
<dd><p><var class="var">S</var> is a real or complex sparse matrix.
</p>
</dd>
<dt><var class="var">typ</var></dt>
<dd><p>Is the type of the factorization and can be one of
</p>
<dl class="table">
<dt><code class="code">&quot;sym&quot;</code> (default)</dt>
<dd><p>Factorize <var class="var">S</var>.  Assumes <var class="var">S</var> is symmetric and uses the upper
triangular portion of the matrix.
</p>
</dd>
<dt><code class="code">&quot;col&quot;</code></dt>
<dd><p>Factorize <code class="code"><var class="var">S</var>' * <var class="var">S</var></code>.
</p>
</dd>
<dt><code class="code">&quot;row&quot;</code></dt>
<dd><p>Factorize <code class="code"><var class="var">S</var> * <var class="var">S</var>'</code>.
</p>
</dd>
<dt><code class="code">&quot;lo&quot;</code></dt>
<dd><p>Factorize <code class="code"><var class="var">S</var>'</code>.  Assumes <var class="var">S</var> is symmetric and uses the lower
triangular portion of the matrix.
</p></dd>
</dl>

</dd>
<dt><var class="var">mode</var></dt>
<dd><p>When <var class="var">mode</var> is unspecified return the Cholesky&nbsp;factorization for
<var class="var">R</var>.  If <var class="var">mode</var> is <code class="code">&quot;lower&quot;</code> or <code class="code">&quot;L&quot;</code> then return
the conjugate transpose <code class="code"><var class="var">R</var>'</code> which is a lower triangular factor.
The conjugate transpose version is faster and uses less memory, but still
returns the same values for all other outputs: <var class="var">count</var>, <var class="var">h</var>,
<var class="var">parent</var>, and <var class="var">post</var>.
</p></dd>
</dl>

<p>The output variables are:
</p>
<dl class="table">
<dt><var class="var">count</var></dt>
<dd><p>The row counts of the Cholesky&nbsp;factorization as determined by
<var class="var">typ</var>.  The computational difficulty of performing the true
factorization using <code class="code">chol</code> is <code class="code">sum (<var class="var">count</var> .^ 2)</code>.
</p>
</dd>
<dt><var class="var">h</var></dt>
<dd><p>The height of the elimination tree.
</p>
</dd>
<dt><var class="var">parent</var></dt>
<dd><p>The elimination tree itself.
</p>
</dd>
<dt><var class="var">post</var></dt>
<dd><p>A sparse boolean matrix whose structure is that of the
Cholesky&nbsp;factorization as determined by <var class="var">typ</var>.
</p></dd>
</dl>

<p><strong class="strong">See also:</strong> <a class="ref" href="Matrix-Factorizations.html#XREFchol">chol</a>, <a class="ref" href="Information.html#XREFetree">etree</a>, <a class="ref" href="Information.html#XREFtreelayout">treelayout</a>.
</p></dd></dl>


<p>For non square matrices, the user can also utilize the <code class="code">spaugment</code>
function to find a least squares solution to a linear equation.
</p>
<a class="anchor" id="XREFspaugment"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-spaugment"><span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">spaugment</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">c</var>)</code><a class="copiable-link" href="#index-spaugment"> &para;</a></span></dt>
<dd><p>Create the augmented matrix of <var class="var">A</var>.
</p>
<p>This is given by
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[<var class="var">c</var> * eye(<var class="var">m</var>, <var class="var">m</var>), <var class="var">A</var>;
            <var class="var">A</var>', zeros(<var class="var">n</var>, <var class="var">n</var>)]
</pre></div></div>

<p>This is related to the least squares solution of
<code class="code"><var class="var">A</var> \ <var class="var">b</var></code>, by
</p>
<div class="example">
<div class="group"><pre class="example-preformatted"><var class="var">s</var> * [ <var class="var">r</var> / <var class="var">c</var>; x] = [ <var class="var">b</var>, zeros(<var class="var">n</var>, columns(<var class="var">b</var>)) ]
</pre></div></div>

<p>where <var class="var">r</var> is the residual error
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">r</var> = <var class="var">b</var> - <var class="var">A</var> * <var class="var">x</var>
</pre></div>

<p>As the matrix <var class="var">s</var> is symmetric indefinite it can be factorized with
<code class="code">lu</code>, and the minimum norm solution can therefore be found without the
need for a <code class="code">qr</code> factorization.  As the residual error will be
<code class="code">zeros (<var class="var">m</var>, <var class="var">m</var>)</code> for underdetermined problems, and example
can be
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">m = 11; n = 10; mn = max (m, n);
A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
             [-1, 0, 1], m, n);
x0 = A \ ones (m,1);
s = spaugment (A);
[L, U, P, Q] = lu (s);
x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
x1 = x1(end - n + 1 : end);
</pre></div></div>

<p>To find the solution of an overdetermined problem needs an estimate of the
residual error <var class="var">r</var> and so it is more complex to formulate a minimum norm
solution using the <code class="code">spaugment</code> function.
</p>
<p>In general the left division operator is more stable and faster than using
the <code class="code">spaugment</code> function.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Arithmetic-Ops.html#XREFmldivide">mldivide</a>.
</p></dd></dl>


<p>Finally, the function <code class="code">eigs</code> can be used to calculate a limited
number of eigenvalues and eigenvectors based on a selection criteria
and likewise for <code class="code">svds</code> which calculates a limited number of
singular values and vectors.
</p>
<a class="anchor" id="XREFeigs"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-eigs"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-eigs"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-eigs-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>, <var class="var">sigma</var>)</code><a class="copiable-link" href="#index-eigs-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>, <var class="var">sigma</var>, <var class="var">opts</var>)</code><a class="copiable-link" href="#index-eigs-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-4"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-eigs-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-5"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-eigs-5"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-6"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">k</var>, <var class="var">sigma</var>)</code><a class="copiable-link" href="#index-eigs-6"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-7"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">B</var>, <var class="var">k</var>, <var class="var">sigma</var>, <var class="var">opts</var>)</code><a class="copiable-link" href="#index-eigs-7"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-8"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>)</code><a class="copiable-link" href="#index-eigs-8"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-9"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-eigs-9"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-10"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">k</var>, <var class="var">sigma</var>)</code><a class="copiable-link" href="#index-eigs-10"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-11"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">k</var>, <var class="var">sigma</var>, <var class="var">opts</var>)</code><a class="copiable-link" href="#index-eigs-11"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-12"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">B</var>)</code><a class="copiable-link" href="#index-eigs-12"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-13"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">B</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-eigs-13"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-14"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">B</var>, <var class="var">k</var>, <var class="var">sigma</var>)</code><a class="copiable-link" href="#index-eigs-14"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-15"><span class="category-def">: </span><span><code class="def-type"><var class="var">d</var> =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(<var class="var">Af</var>, <var class="var">n</var>, <var class="var">B</var>, <var class="var">k</var>, <var class="var">sigma</var>, <var class="var">opts</var>)</code><a class="copiable-link" href="#index-eigs-15"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-16"><span class="category-def">: </span><span><code class="def-type">[<var class="var">V</var>, <var class="var">D</var>] =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-eigs-16"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-eigs-17"><span class="category-def">: </span><span><code class="def-type">[<var class="var">V</var>, <var class="var">D</var>, <var class="var">flag</var>] =</code> <strong class="def-name">eigs</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-eigs-17"> &para;</a></span></dt>
<dd><p>Calculate a limited number of eigenvalues and eigenvectors based on a
selection criteria.
</p>
<p>By default, <code class="code">eigs</code> solve the equation
where
is the corresponding eigenvector.  If given the positive definite matrix
<var class="var">B</var> then <code class="code">eigs</code> solves the general eigenvalue equation
</p>
<p>The input <var class="var">A</var> is a square matrix of dimension <var class="var">n</var>-by-<var class="var">n</var>.
Typically, <var class="var">A</var> is also large and sparse.
</p>
<p>The input <var class="var">B</var> for the generalized eigenvalue problem is a square matrix
with the same size as <var class="var">A</var> (<var class="var">n</var>-by-<var class="var">n</var>).  Typically, <var class="var">B</var> is
also large and sparse.
</p>
<p>The number of eigenvalues and eigenvectors to calculate is given by <var class="var">k</var>
and defaults to 6.
</p>
<p>The argument <var class="var">sigma</var> determines which eigenvalues are returned.
<var class="var">sigma</var> can be either a scalar or a string.  When <var class="var">sigma</var> is a
scalar, the <var class="var">k</var> eigenvalues closest to <var class="var">sigma</var> are returned.  If
<var class="var">sigma</var> is a string, it must be one of the following values.
</p>
<dl class="table">
<dt><code class="code">&quot;lm&quot;</code></dt>
<dd><p>Largest Magnitude (default).
</p>
</dd>
<dt><code class="code">&quot;sm&quot;</code></dt>
<dd><p>Smallest Magnitude.
</p>
</dd>
<dt><code class="code">&quot;la&quot;</code></dt>
<dd><p>Largest Algebraic (valid only for real symmetric problems).
</p>
</dd>
<dt><code class="code">&quot;sa&quot;</code></dt>
<dd><p>Smallest Algebraic (valid only for real symmetric problems).
</p>
</dd>
<dt><code class="code">&quot;be&quot;</code></dt>
<dd><p>Both Ends, with one more from the high-end if <var class="var">k</var> is odd (valid only for
real symmetric problems).
</p>
</dd>
<dt><code class="code">&quot;lr&quot;</code></dt>
<dd><p>Largest Real part (valid only for complex or unsymmetric problems).
</p>
</dd>
<dt><code class="code">&quot;sr&quot;</code></dt>
<dd><p>Smallest Real part (valid only for complex or unsymmetric problems).
</p>
</dd>
<dt><code class="code">&quot;li&quot;</code></dt>
<dd><p>Largest Imaginary part (valid only for complex or unsymmetric problems).
</p>
</dd>
<dt><code class="code">&quot;si&quot;</code></dt>
<dd><p>Smallest Imaginary part (valid only for complex or unsymmetric problems).
</p></dd>
</dl>

<p>If <var class="var">opts</var> is given, it is a structure defining possible options that
<code class="code">eigs</code> should use.  The fields of the <var class="var">opts</var> structure are:
</p>
<dl class="table">
<dt><code class="code">issym</code></dt>
<dd><p>If <var class="var">Af</var> is given then this flag (true/false) determines whether the
function <var class="var">Af</var> defines a symmetric problem.  It is ignored if a matrix
<var class="var">A</var> is given.  The default is false.
</p>
</dd>
<dt><code class="code">isreal</code></dt>
<dd><p>If <var class="var">Af</var> is given then this flag (true/false) determines whether the
function <var class="var">Af</var> defines a real problem.  It is ignored if a matrix <var class="var">A</var>
is given.  The default is true.
</p>
</dd>
<dt><code class="code">tol</code></dt>
<dd><p>Defines the required convergence tolerance, calculated as
<code class="code">tol * norm (A)</code>.  The default is <code class="code">eps</code>.
</p>
</dd>
<dt><code class="code">maxit</code></dt>
<dd><p>The maximum number of iterations.  The default is 300.
</p>
</dd>
<dt><code class="code">p</code></dt>
<dd><p>The number of Lanczos basis vectors to use.  More vectors will
result in faster convergence, but a greater use of memory.  The optimal
value of <code class="code">p</code> is problem dependent and should be in the range
<code class="code"><var class="var">k</var> + 1</code> to <var class="var">n</var>.  The default value is <code class="code">2 * <var class="var">k</var></code>.
</p>
</dd>
<dt><code class="code">v0</code></dt>
<dd><p>The starting vector for the algorithm.  An initial vector close to the final
vector will speed up convergence.  The default is for <small class="sc">ARPACK</small> to
randomly generate a starting vector.  If specified, <code class="code">v0</code> must be
an <var class="var">n</var>-by-1 vector where <code class="code"><var class="var">n</var> = rows (<var class="var">A</var>)</code>.
</p>
</dd>
<dt><code class="code">disp</code></dt>
<dd><p>The level of diagnostic printout (0|1|2).  If <code class="code">disp</code> is 0 then
diagnostics are disabled.  The default value is 0.
</p>
</dd>
<dt><code class="code">cholB</code></dt>
<dd><p>If the generalized eigenvalue problem is being calculated, this flag
(true/false) specifies whether the <var class="var">B</var> input represents
<code class="code">chol (<var class="var">B</var>)</code> or simply the matrix <var class="var">B</var>.  The default is false.
</p>
</dd>
<dt><code class="code">permB</code></dt>
<dd><p>The permutation vector of the Cholesky&nbsp;factorization for <var class="var">B</var> if
<code class="code">cholB</code> is true.  It is obtained by
<code class="code">[R, ~, permB] = chol (<var class="var">B</var>, <code class="code">&quot;vector&quot;</code>)</code>.  The default is
<code class="code">1:<var class="var">n</var></code>.
</p>
</dd>
</dl>

<p>It is also possible to represent <var class="var">A</var> by a function denoted <var class="var">Af</var>.
<var class="var">Af</var> must be followed by a scalar argument <var class="var">n</var> defining the length
of the vector argument accepted by <var class="var">Af</var>.  <var class="var">Af</var> can be a function
handle, an inline function, or a string.  When <var class="var">Af</var> is a string it
holds the name of the function to use.
</p>
<p><var class="var">Af</var> is a function of the form <code class="code">y = Af (x)</code> where the required
return value of <var class="var">Af</var> is determined by the value of <var class="var">sigma</var>.
The four possible forms are
</p>
<dl class="table">
<dt><code class="code">A * x</code></dt>
<dd><p>if <var class="var">sigma</var> is not given or is a string other than &quot;sm&quot;.
</p>
</dd>
<dt><code class="code">A \ x</code></dt>
<dd><p>if <var class="var">sigma</var> is 0 or &quot;sm&quot;.
</p>
</dd>
<dt><code class="code">(A - sigma * I) \ x</code></dt>
<dd><p>if <var class="var">sigma</var> is a scalar not equal to 0; <code class="code">I</code> is the identity matrix
of the same size as <var class="var">A</var>.
</p>
</dd>
<dt><code class="code">(A - sigma * B) \ x</code></dt>
<dd><p>for the general eigenvalue problem.
</p></dd>
</dl>

<p>The return arguments and their form depend on the number of return arguments
requested.  For a single return argument, a column vector <var class="var">d</var> of length
<var class="var">k</var> is returned containing the <var class="var">k</var> eigenvalues that have been
found.  For two return arguments, <var class="var">V</var> is an <var class="var">n</var>-by-<var class="var">k</var> matrix
whose columns are the <var class="var">k</var> eigenvectors corresponding to the returned
eigenvalues.  The eigenvalues themselves are returned in <var class="var">D</var> in the
form of a <var class="var">k</var>-by-<var class="var">k</var> matrix, where the elements on the diagonal
are the eigenvalues.
</p>
<p>The third return argument <var class="var">flag</var> returns the status of the convergence.
If <var class="var">flag</var> is 0 then all eigenvalues have converged.  Any other value
indicates a failure to converge.
</p>
<p>Programming Notes: For small problems, <var class="var">n</var> &lt; 500, consider using
<code class="code">eig (full (<var class="var">A</var>))</code>.
</p>
<p>If <small class="sc">ARPACK</small> fails to converge consider increasing the number of
Lanczos vectors (<var class="var">opt</var>.p), increasing the number of iterations
(<var class="var">opt</var>.maxiter), or decreasing the tolerance (<var class="var">opt</var>.tol).
</p>
<p>Reference:
This function is based on the <small class="sc">ARPACK</small> package, written by
R. Lehoucq, K. Maschhoff, D. Sorensen, and C. Yang.  For more
information see <a class="url" href="http://www.caam.rice.edu/software/ARPACK/">http://www.caam.rice.edu/software/ARPACK/</a>.
</p>

<p><strong class="strong">See also:</strong> <a class="ref" href="Basic-Matrix-Functions.html#XREFeig">eig</a>, <a class="ref" href="#XREFsvds">svds</a>.
</p></dd></dl>


<a class="anchor" id="XREFsvds"></a><span style="display:block; margin-top:-4.5ex;">&nbsp;</span>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-svds"><span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">svds</strong> <code class="def-code-arguments">(<var class="var">A</var>)</code><a class="copiable-link" href="#index-svds"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svds-1"><span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">svds</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>)</code><a class="copiable-link" href="#index-svds-1"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svds-2"><span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">svds</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>, <var class="var">sigma</var>)</code><a class="copiable-link" href="#index-svds-2"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svds-3"><span class="category-def">: </span><span><code class="def-type"><var class="var">s</var> =</code> <strong class="def-name">svds</strong> <code class="def-code-arguments">(<var class="var">A</var>, <var class="var">k</var>, <var class="var">sigma</var>, <var class="var">opts</var>)</code><a class="copiable-link" href="#index-svds-3"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svds-4"><span class="category-def">: </span><span><code class="def-type">[<var class="var">u</var>, <var class="var">s</var>, <var class="var">v</var>] =</code> <strong class="def-name">svds</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-svds-4"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-svds-5"><span class="category-def">: </span><span><code class="def-type">[<var class="var">u</var>, <var class="var">s</var>, <var class="var">v</var>, <var class="var">flag</var>] =</code> <strong class="def-name">svds</strong> <code class="def-code-arguments">(&hellip;)</code><a class="copiable-link" href="#index-svds-5"> &para;</a></span></dt>
<dd>
<p>Find a few singular values of the matrix <var class="var">A</var>.
</p>
<p>The singular values are calculated using
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">[<var class="var">m</var>, <var class="var">n</var>] = size (<var class="var">A</var>);
<var class="var">s</var> = eigs ([sparse(<var class="var">m</var>, <var class="var">m</var>), <var class="var">A</var>;
                     <var class="var">A</var>', sparse(<var class="var">n</var>, <var class="var">n</var>)])
</pre></div></div>

<p>The eigenvalues returned by <code class="code">eigs</code> correspond to the singular values
of <var class="var">A</var>.  The number of singular values to calculate is given by <var class="var">k</var>
and defaults to 6.
</p>
<p>The argument <var class="var">sigma</var> specifies which singular values to find.  When
<var class="var">sigma</var> is the string <code class="code">'L'</code>, the default, the largest singular
values of <var class="var">A</var> are found.  Otherwise, <var class="var">sigma</var> must be a real scalar
and the singular values closest to <var class="var">sigma</var> are found.  As a corollary,
<code class="code"><var class="var">sigma</var> = 0</code> finds the smallest singular values.  Note that for
relatively small values of <var class="var">sigma</var>, there is a chance that the
requested number of singular values will not be found.  In that case
<var class="var">sigma</var> should be increased.
</p>
<p><var class="var">opts</var> is a structure defining options that <code class="code">svds</code> will pass
to <code class="code">eigs</code>.  The possible fields of this structure are documented in
<code class="code">eigs</code>.  By default, <code class="code">svds</code> sets the following three fields:
</p>
<dl class="table">
<dt><code class="code">tol</code></dt>
<dd><p>The required convergence tolerance for the singular values.  The default
value is 1e-10.  <code class="code">eigs</code> is passed <code class="code"><var class="var">tol</var> / sqrt (2)</code>.
</p>
</dd>
<dt><code class="code">maxit</code></dt>
<dd><p>The maximum number of iterations.  The default is 300.
</p>
</dd>
<dt><code class="code">disp</code></dt>
<dd><p>The level of diagnostic printout (0|1|2).  If <code class="code">disp</code> is 0 then
diagnostics are disabled.  The default value is 0.
</p></dd>
</dl>

<p>If more than one output is requested then <code class="code">svds</code> will return an
approximation of the singular value decomposition of <var class="var">A</var>
</p>
<div class="example">
<pre class="example-preformatted"><var class="var">A</var>_approx = <var class="var">u</var>*<var class="var">s</var>*<var class="var">v</var>'
</pre></div>

<p>where <var class="var">A</var>_approx is a matrix of size <var class="var">A</var> but only rank <var class="var">k</var>.
</p>
<p><var class="var">flag</var> returns 0 if the algorithm has successfully converged, and 1
otherwise.  The test for convergence is
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">norm (<var class="var">A</var>*<var class="var">v</var> - <var class="var">u</var>*<var class="var">s</var>, 1) &lt;= <var class="var">tol</var> * norm (<var class="var">A</var>, 1)
</pre></div></div>

<p><code class="code">svds</code> is best for finding only a few singular values from a large
sparse matrix.  Otherwise, <code class="code">svd (full (<var class="var">A</var>))</code> will likely be more
efficient.
</p>
<p><strong class="strong">See also:</strong> <a class="ref" href="Matrix-Factorizations.html#XREFsvd">svd</a>, <a class="ref" href="#XREFeigs">eigs</a>.
</p></dd></dl>


</div>
<div class="footnotes-segment">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT10" href="#DOCF10">(10)</a></h5>
<p>The <small class="sc">CHOLMOD</small>, <small class="sc">UMFPACK</small> and <small class="sc">CXSPARSE</small>
packages were written by Tim Davis and are available at
<a class="url" href="http://faculty.cse.tamu.edu/davis/suitesparse.html">http://faculty.cse.tamu.edu/davis/suitesparse.html</a></p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Iterative-Techniques.html">Iterative Techniques Applied to Sparse Matrices</a>, Previous: <a href="Basics.html">Creation and Manipulation of Sparse Matrices</a>, Up: <a href="Sparse-Matrices.html">Sparse Matrices</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
